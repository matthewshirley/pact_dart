// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(
      arg0,
      arg1,
    );
  }

  late final _signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('signal');
  late final _signal = _signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int getpriority(
    int arg0,
    int arg1,
  ) {
    return _getpriority(
      arg0,
      arg1,
    );
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
          'getpriority');
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(
    int arg0,
    int arg1,
  ) {
    return _getiopolicy_np(
      arg0,
      arg1,
    );
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'getiopolicy_np');
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _getrlimit(
      arg0,
      arg1,
    );
  }

  late final _getrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(
    int arg0,
    ffi.Pointer<rusage> arg1,
  ) {
    return _getrusage(
      arg0,
      arg1,
    );
  }

  late final _getrusagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>>(
      'getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setpriority(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
          'setpriority');
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setiopolicy_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'setiopolicy_np');
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _setrlimit(
      arg0,
      arg1,
    );
  }

  late final _setrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _wait(
      arg0,
    );
  }

  late final _waitPtr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait = _waitPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
  ) {
    return _waitpid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _waitpidPtr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>>('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    idtype_t arg0,
    Dart__uint32_t arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(
      arg0.value,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _waitidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, id_t, ffi.Pointer<siginfo_t>,
              ffi.Int)>>('waitid');
  late final _waitid = _waitidPtr
      .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  int wait3(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
    ffi.Pointer<rusage> arg2,
  ) {
    return _wait3(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wait3Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)>>('wait3');
  late final _wait3 = _wait3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  int wait4(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
    ffi.Pointer<rusage> arg3,
  ) {
    return _wait4(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _wait4Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Pointer<rusage>)>>('wait4');
  late final _wait4 = _wait4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  ffi.Pointer<ffi.Void> malloc_type_malloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_malloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_malloc');
  late final _malloc_type_malloc = _malloc_type_mallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_calloc(
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_calloc(
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size, malloc_type_id_t)>>('malloc_type_calloc');
  late final _malloc_type_calloc = _malloc_type_callocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  void malloc_type_free(
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_free(
      ptr,
      type_id,
    );
  }

  late final _malloc_type_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, malloc_type_id_t)>>('malloc_type_free');
  late final _malloc_type_free = _malloc_type_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_realloc(
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_realloc');
  late final _malloc_type_realloc = _malloc_type_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_valloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_valloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_valloc');
  late final _malloc_type_valloc = _malloc_type_vallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_aligned_alloc(
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size,
              malloc_type_id_t)>>('malloc_type_aligned_alloc');
  late final _malloc_type_aligned_alloc = _malloc_type_aligned_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  int malloc_type_posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_posix_memalign(
      memptr,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_posix_memalign');
  late final _malloc_type_posix_memalign =
      _malloc_type_posix_memalignPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_malloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_malloc');
  late final _malloc_type_zone_malloc = _malloc_type_zone_mallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
    ffi.Pointer<malloc_zone_t> zone,
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_calloc(
      zone,
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_calloc');
  late final _malloc_type_zone_calloc = _malloc_type_zone_callocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<malloc_zone_t>, int, int, int)>();

  void malloc_type_zone_free(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_zone_free(
      zone,
      ptr,
      type_id,
    );
  }

  late final _malloc_type_zone_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>,
              malloc_type_id_t)>>('malloc_type_zone_free');
  late final _malloc_type_zone_free = _malloc_type_zone_freePtr.asFunction<
      void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_realloc(
      zone,
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_realloc');
  late final _malloc_type_zone_realloc =
      _malloc_type_zone_reallocPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_valloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_valloc');
  late final _malloc_type_zone_valloc = _malloc_type_zone_vallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
    ffi.Pointer<malloc_zone_t> zone,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_memalign(
      zone,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_memalign');
  late final _malloc_type_zone_memalign =
      _malloc_type_zone_memalignPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __count,
    int __size,
  ) {
    return _calloc(
      __count,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _free(
      arg0,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> reallocf(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _reallocf(
      __ptr,
      __size,
    );
  }

  late final _reallocfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('reallocf');
  late final _reallocf = _reallocfPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(
    int arg0,
  ) {
    return _abs(
      arg0,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _atexit(
      arg0,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _at_quick_exit(
      arg0,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  double atof(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atof(
      arg0,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoi(
      arg0,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atol(
      arg0,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoll(
      arg0,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  div_t div(
    int arg0,
    int arg1,
  ) {
    return _div(
      arg0,
      arg1,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(
    int arg0,
  ) {
    return _exit(
      arg0,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getenv(
      arg0,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(
    int arg0,
  ) {
    return _labs(
      arg0,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(
    int arg0,
    int arg1,
  ) {
    return _ldiv(
      arg0,
      arg1,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(
    int arg0,
  ) {
    return _llabs(
      arg0,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(
    int arg0,
    int arg1,
  ) {
    return _lldiv(
      arg0,
      arg1,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __n,
  ) {
    return _mbstowcs(
      arg0,
      arg1,
      __n,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __n,
  ) {
    return _mbtowc(
      arg0,
      arg1,
      __n,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void quick_exit(
    int arg0,
  ) {
    return _quick_exit(
      arg0,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int arg0,
  ) {
    return _srand(
      arg0,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(
      arg0,
      arg1,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(
      arg0,
      arg1,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int system(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _system(
      arg0,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int __n,
  ) {
    return _wcstombs(
      arg0,
      arg1,
      __n,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _wctomb(
      arg0,
      arg1,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _a64l(
      arg0,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _erand48(
      arg0,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int grantpt(
    int arg0,
  ) {
    return _grantpt(
      arg0,
    );
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __size,
  ) {
    return _initstate(
      arg0,
      arg1,
      __size,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _jrand48(
      arg0,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(
    int arg0,
  ) {
    return _l64a(
      arg0,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _lcong48(
      arg0,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _nrand48(
      arg0,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(
    int arg0,
  ) {
    return _posix_openpt(
      arg0,
    );
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(
    int arg0,
  ) {
    return _ptsname(
      arg0,
    );
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ptsname');
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ptsname_r(
    int fildes,
    ffi.Pointer<ffi.Char> buffer,
    int buflen,
  ) {
    return _ptsname_r(
      fildes,
      buffer,
      buflen,
    );
  }

  late final _ptsname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ptsname_r');
  late final _ptsname_r =
      _ptsname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int putenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _putenv(
      arg0,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> arg0,
  ) {
    return _rand_r(
      arg0,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(
      arg0,
      arg1,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _seed48(
      arg0,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(
      __name,
      __value,
      __overwrite,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setstate(
      arg0,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(
    int arg0,
  ) {
    return _srand48(
      arg0,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(
    int arg0,
  ) {
    return _srandom(
      arg0,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(
    int arg0,
  ) {
    return _unlockpt(
      arg0,
    );
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unsetenv(
      arg0,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_addrandom(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    int __datlen,
  ) {
    return _arc4random_addrandom(
      arg0,
      __datlen,
    );
  }

  late final _arc4random_addrandomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('arc4random_addrandom');
  late final _arc4random_addrandom = _arc4random_addrandomPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _arc4random_buf(
      __buf,
      __nbytes,
    );
  }

  late final _arc4random_bufPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  void arc4random_stir() {
    return _arc4random_stir();
  }

  late final _arc4random_stirPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('arc4random_stir');
  late final _arc4random_stir =
      _arc4random_stirPtr.asFunction<void Function()>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> cgetcap(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _cgetcap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetcapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('cgetcap');
  late final _cgetcap = _cgetcapPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int cgetclose() {
    return _cgetclose();
  }

  late final _cgetclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('cgetclose');
  late final _cgetclose = _cgetclosePtr.asFunction<int Function()>();

  int cgetent(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _cgetent(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('cgetent');
  late final _cgetent = _cgetentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int cgetfirst(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetfirst(
      arg0,
      arg1,
    );
  }

  late final _cgetfirstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetfirst');
  late final _cgetfirst = _cgetfirstPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetmatch(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _cgetmatch(
      arg0,
      arg1,
    );
  }

  late final _cgetmatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('cgetmatch');
  late final _cgetmatch = _cgetmatchPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int cgetnext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetnext(
      arg0,
      arg1,
    );
  }

  late final _cgetnextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetnext');
  late final _cgetnext = _cgetnextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetnum(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Long> arg2,
  ) {
    return _cgetnum(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetnumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Long>)>>('cgetnum');
  late final _cgetnum = _cgetnumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Long>)>();

  int cgetset(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _cgetset(
      arg0,
    );
  }

  late final _cgetsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'cgetset');
  late final _cgetset =
      _cgetsetPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int cgetstr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetstr');
  late final _cgetstr = _cgetstrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetustr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetustr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetustrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetustr');
  late final _cgetustr = _cgetustrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int daemon(
    int arg0,
    int arg1,
  ) {
    return _daemon(
      arg0,
      arg1,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> devname(
    int arg0,
    int arg1,
  ) {
    return _devname(
      arg0,
      arg1,
    );
  }

  late final _devnamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>>(
      'devname');
  late final _devname =
      _devnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  ffi.Pointer<ffi.Char> devname_r(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _devname_r(
      arg0,
      arg1,
      buf,
      len,
    );
  }

  late final _devname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              dev_t, mode_t, ffi.Pointer<ffi.Char>, ffi.Int)>>('devname_r');
  late final _devname_r = _devname_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> getbsize(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.Long> arg1,
  ) {
    return _getbsize(
      arg0,
      arg1,
    );
  }

  late final _getbsizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>>('getbsize');
  late final _getbsize = _getbsizePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> arg0,
    int __nelem,
  ) {
    return _getloadavg(
      arg0,
      __nelem,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Char> getprogname() {
    return _getprogname();
  }

  late final _getprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getprogname');
  late final _getprogname =
      _getprognamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setprogname(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setprogname(
      arg0,
    );
  }

  late final _setprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setprogname');
  late final _setprogname =
      _setprognamePtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int heapsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _heapsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _heapsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('heapsort');
  late final _heapsort = _heapsortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int mergesort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _mergesort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _mergesortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('mergesort');
  late final _mergesort = _mergesortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _psortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort');
  late final _psort = _psortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _psort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort_r');
  late final _psort_r = _psort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  void qsort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _qsort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort_r');
  late final _qsort_r = _qsort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  int radixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _radixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _radixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('radixsort');
  late final _radixsort = _radixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rpmatch(
      arg0,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sradixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _sradixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _sradixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('sradixsort');
  late final _sradixsort = _sradixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  void sranddev() {
    return _sranddev();
  }

  late final _sranddevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sranddev');
  late final _sranddev = _sranddevPtr.asFunction<void Function()>();

  void srandomdev() {
    return _srandomdev();
  }

  late final _srandomdevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('srandomdev');
  late final _srandomdev = _srandomdevPtr.asFunction<void Function()>();

  int strtonum(
    ffi.Pointer<ffi.Char> __numstr,
    int __minval,
    int __maxval,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
  ) {
    return _strtonum(
      __numstr,
      __minval,
      __maxval,
      __errstrp,
    );
  }

  late final _strtonumPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>, ffi.LongLong,
              ffi.LongLong, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtonum');
  late final _strtonum = _strtonumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  /// Returns the current library version
  ffi.Pointer<ffi.Char> pactffi_version() {
    return _pactffi_version();
  }

  late final _pactffi_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pactffi_version');
  late final _pactffi_version =
      _pactffi_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Initialise the mock server library, can provide an environment variable name to use to
  /// set the log levels. This function should only be called once, as it tries to install a global
  /// tracing subscriber.
  ///
  /// # Safety
  ///
  /// log_env_var must be a valid NULL terminated UTF-8 string.
  void pactffi_init(
    ffi.Pointer<ffi.Char> log_env_var,
  ) {
    return _pactffi_init(
      log_env_var,
    );
  }

  late final _pactffi_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'pactffi_init');
  late final _pactffi_init =
      _pactffi_initPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Initialises logging, and sets the log level explicitly. This function should only be called
  /// once, as it tries to install a global tracing subscriber.
  ///
  /// * `log_level` - String. One of TRACE, DEBUG, INFO, WARN, ERROR, NONE/OFF. Case-insensitive. Defaults to INFO.
  ///
  /// # Safety
  ///
  /// Exported functions are inherently unsafe.
  void pactffi_init_with_log_level(
    ffi.Pointer<ffi.Char> level,
  ) {
    return _pactffi_init_with_log_level(
      level,
    );
  }

  late final _pactffi_init_with_log_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'pactffi_init_with_log_level');
  late final _pactffi_init_with_log_level = _pactffi_init_with_log_levelPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Enable ANSI coloured output on Windows. On non-Windows platforms, this function is a no-op.
  ///
  /// # Safety
  ///
  /// This function is safe.
  void pactffi_enable_ansi_support() {
    return _pactffi_enable_ansi_support();
  }

  late final _pactffi_enable_ansi_supportPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'pactffi_enable_ansi_support');
  late final _pactffi_enable_ansi_support =
      _pactffi_enable_ansi_supportPtr.asFunction<void Function()>();

  /// Log using the shared core logging facility.
  ///
  /// This is useful for callers to have a single set of logs.
  ///
  /// * `source` - String. The source of the log, such as the class or caller framework to
  /// disambiguate log lines from the rust logging (e.g. pact_go)
  /// * `log_level` - String. One of TRACE, DEBUG, INFO, WARN, ERROR. Case-insensitive. Defaults to INFO.
  /// * `message` - Message to log
  ///
  /// # Safety
  /// This function will fail if any of the pointers passed to it are invalid.
  void pactffi_log_message(
    ffi.Pointer<ffi.Char> source,
    ffi.Pointer<ffi.Char> log_level,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _pactffi_log_message(
      source,
      log_level,
      message,
    );
  }

  late final _pactffi_log_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_log_message');
  late final _pactffi_log_message = _pactffi_log_messagePtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Match a pair of messages, producing a collection of mismatches,
  /// which is empty if the two messages matched.
  ffi.Pointer<Mismatches> pactffi_match_message(
    ffi.Pointer<Message> msg_1,
    ffi.Pointer<Message> msg_2,
  ) {
    return _pactffi_match_message(
      msg_1,
      msg_2,
    );
  }

  late final _pactffi_match_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Mismatches> Function(ffi.Pointer<Message>,
              ffi.Pointer<Message>)>>('pactffi_match_message');
  late final _pactffi_match_message = _pactffi_match_messagePtr.asFunction<
      ffi.Pointer<Mismatches> Function(
          ffi.Pointer<Message>, ffi.Pointer<Message>)>();

  /// Get an iterator over mismatches.
  ffi.Pointer<MismatchesIterator> pactffi_mismatches_get_iter(
    ffi.Pointer<Mismatches> mismatches,
  ) {
    return _pactffi_mismatches_get_iter(
      mismatches,
    );
  }

  late final _pactffi_mismatches_get_iterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<MismatchesIterator> Function(
              ffi.Pointer<Mismatches>)>>('pactffi_mismatches_get_iter');
  late final _pactffi_mismatches_get_iter =
      _pactffi_mismatches_get_iterPtr.asFunction<
          ffi.Pointer<MismatchesIterator> Function(ffi.Pointer<Mismatches>)>();

  /// Delete mismatches
  void pactffi_mismatches_delete(
    ffi.Pointer<Mismatches> mismatches,
  ) {
    return _pactffi_mismatches_delete(
      mismatches,
    );
  }

  late final _pactffi_mismatches_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Mismatches>)>>(
          'pactffi_mismatches_delete');
  late final _pactffi_mismatches_delete = _pactffi_mismatches_deletePtr
      .asFunction<void Function(ffi.Pointer<Mismatches>)>();

  /// Get the next mismatch from a mismatches iterator.
  ///
  /// Returns a null pointer if no mismatches remain.
  ffi.Pointer<Mismatch> pactffi_mismatches_iter_next(
    ffi.Pointer<MismatchesIterator> iter,
  ) {
    return _pactffi_mismatches_iter_next(
      iter,
    );
  }

  late final _pactffi_mismatches_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<Mismatch> Function(ffi.Pointer<MismatchesIterator>)>>(
      'pactffi_mismatches_iter_next');
  late final _pactffi_mismatches_iter_next =
      _pactffi_mismatches_iter_nextPtr.asFunction<
          ffi.Pointer<Mismatch> Function(ffi.Pointer<MismatchesIterator>)>();

  /// Delete a mismatches iterator when you're done with it.
  void pactffi_mismatches_iter_delete(
    ffi.Pointer<MismatchesIterator> iter,
  ) {
    return _pactffi_mismatches_iter_delete(
      iter,
    );
  }

  late final _pactffi_mismatches_iter_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<MismatchesIterator>)>>(
      'pactffi_mismatches_iter_delete');
  late final _pactffi_mismatches_iter_delete =
      _pactffi_mismatches_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<MismatchesIterator>)>();

  /// Get a JSON representation of the mismatch.
  ffi.Pointer<ffi.Char> pactffi_mismatch_to_json(
    ffi.Pointer<Mismatch> mismatch,
  ) {
    return _pactffi_mismatch_to_json(
      mismatch,
    );
  }

  late final _pactffi_mismatch_to_jsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Mismatch>)>>('pactffi_mismatch_to_json');
  late final _pactffi_mismatch_to_json = _pactffi_mismatch_to_jsonPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Mismatch>)>();

  /// Get the type of a mismatch.
  ffi.Pointer<ffi.Char> pactffi_mismatch_type(
    ffi.Pointer<Mismatch> mismatch,
  ) {
    return _pactffi_mismatch_type(
      mismatch,
    );
  }

  late final _pactffi_mismatch_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Mismatch>)>>('pactffi_mismatch_type');
  late final _pactffi_mismatch_type = _pactffi_mismatch_typePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Mismatch>)>();

  /// Get a summary of a mismatch.
  ffi.Pointer<ffi.Char> pactffi_mismatch_summary(
    ffi.Pointer<Mismatch> mismatch,
  ) {
    return _pactffi_mismatch_summary(
      mismatch,
    );
  }

  late final _pactffi_mismatch_summaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Mismatch>)>>('pactffi_mismatch_summary');
  late final _pactffi_mismatch_summary = _pactffi_mismatch_summaryPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Mismatch>)>();

  /// Get a description of a mismatch.
  ffi.Pointer<ffi.Char> pactffi_mismatch_description(
    ffi.Pointer<Mismatch> mismatch,
  ) {
    return _pactffi_mismatch_description(
      mismatch,
    );
  }

  late final _pactffi_mismatch_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Mismatch>)>>('pactffi_mismatch_description');
  late final _pactffi_mismatch_description = _pactffi_mismatch_descriptionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Mismatch>)>();

  /// Get an ANSI-compatible description of a mismatch.
  ffi.Pointer<ffi.Char> pactffi_mismatch_ansi_description(
    ffi.Pointer<Mismatch> mismatch,
  ) {
    return _pactffi_mismatch_ansi_description(
      mismatch,
    );
  }

  late final _pactffi_mismatch_ansi_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Mismatch>)>>('pactffi_mismatch_ansi_description');
  late final _pactffi_mismatch_ansi_description =
      _pactffi_mismatch_ansi_descriptionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Mismatch>)>();

  /// Provide the error message from `LAST_ERROR` to the calling C code.
  ///
  /// This function should be called after any other function in the pact_matching FFI
  /// indicates a failure with its own error message, if the caller wants to get more context
  /// on why the error happened.
  ///
  /// Do note that this error-reporting mechanism only reports the top-level error message,
  /// not any source information embedded in the original Rust error type. If you want more
  /// detailed information for debugging purposes, use the logging interface.
  ///
  /// # Params
  ///
  /// * `buffer`: a pointer to an array of `char` of sufficient length to hold the error message.
  /// * `length`: an int providing the length of the `buffer`.
  ///
  /// # Return Codes
  ///
  /// * The number of bytes written to the provided buffer, which may be zero if there is no last error.
  /// * `-1` if the provided buffer is a null pointer.
  /// * `-2` if the provided buffer length is too small for the error message.
  /// * `-3` if the write failed for some other reason.
  /// * `-4` if the error message had an interior NULL
  ///
  /// # Notes
  ///
  /// Note that this function zeroes out any excess in the provided buffer.
  ///
  /// # Error Handling
  ///
  /// The return code must be checked for one of the negative number error codes before the buffer
  /// is used. If an error code is present, the buffer may not be in a usable state.
  ///
  /// If the buffer is longer than needed for the error message, the excess space will be zeroed
  /// as a safety mechanism. This is slightly less efficient than leaving the contents of the buffer
  /// alone, but the difference is expected to be negligible in practice.
  int pactffi_get_error_message(
    ffi.Pointer<ffi.Char> buffer,
    int length,
  ) {
    return _pactffi_get_error_message(
      buffer,
      length,
    );
  }

  late final _pactffi_get_error_messagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'pactffi_get_error_message');
  late final _pactffi_get_error_message = _pactffi_get_error_messagePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Convenience function to direct all logging to stdout.
  int pactffi_log_to_stdout(
    LevelFilter level_filter,
  ) {
    return _pactffi_log_to_stdout(
      level_filter.value,
    );
  }

  late final _pactffi_log_to_stdoutPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'pactffi_log_to_stdout');
  late final _pactffi_log_to_stdout =
      _pactffi_log_to_stdoutPtr.asFunction<int Function(int)>();

  /// Convenience function to direct all logging to stderr.
  int pactffi_log_to_stderr(
    LevelFilter level_filter,
  ) {
    return _pactffi_log_to_stderr(
      level_filter.value,
    );
  }

  late final _pactffi_log_to_stderrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'pactffi_log_to_stderr');
  late final _pactffi_log_to_stderr =
      _pactffi_log_to_stderrPtr.asFunction<int Function(int)>();

  /// Convenience function to direct all logging to a file.
  ///
  /// # Safety
  /// This function will fail if the file_name pointer is invalid or does not point to a NULL
  /// terminated string.
  int pactffi_log_to_file(
    ffi.Pointer<ffi.Char> file_name,
    LevelFilter level_filter,
  ) {
    return _pactffi_log_to_file(
      file_name,
      level_filter.value,
    );
  }

  late final _pactffi_log_to_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('pactffi_log_to_file');
  late final _pactffi_log_to_file = _pactffi_log_to_filePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Convenience function to direct all logging to a task local memory buffer.
  int pactffi_log_to_buffer(
    LevelFilter level_filter,
  ) {
    return _pactffi_log_to_buffer(
      level_filter.value,
    );
  }

  late final _pactffi_log_to_bufferPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'pactffi_log_to_buffer');
  late final _pactffi_log_to_buffer =
      _pactffi_log_to_bufferPtr.asFunction<int Function(int)>();

  /// Initialize the FFI logger with no sinks.
  ///
  /// This initialized logger does nothing until `pactffi_logger_apply` has been called.
  ///
  /// # Usage
  ///
  /// ```c
  /// pactffi_logger_init();
  /// ```
  ///
  /// # Safety
  ///
  /// This function is always safe to call.
  void pactffi_logger_init() {
    return _pactffi_logger_init();
  }

  late final _pactffi_logger_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('pactffi_logger_init');
  late final _pactffi_logger_init =
      _pactffi_logger_initPtr.asFunction<void Function()>();

  /// Attach an additional sink to the thread-local logger.
  ///
  /// This logger does nothing until `pactffi_logger_apply` has been called.
  ///
  /// Types of sinks can be specified:
  ///
  /// - stdout (`pactffi_logger_attach_sink("stdout", LevelFilter_Info)`)
  /// - stderr (`pactffi_logger_attach_sink("stderr", LevelFilter_Debug)`)
  /// - file w/ file path (`pactffi_logger_attach_sink("file /some/file/path", LevelFilter_Trace)`)
  /// - buffer (`pactffi_logger_attach_sink("buffer", LevelFilter_Debug)`)
  ///
  /// # Usage
  ///
  /// ```c
  /// int result = pactffi_logger_attach_sink("file /some/file/path", LogLevel_Filter);
  /// ```
  ///
  /// # Error Handling
  ///
  /// The return error codes are as follows:
  ///
  /// - `-1`: Can't set logger (applying the logger failed, perhaps because one is applied already).
  /// - `-2`: No logger has been initialized (call `pactffi_logger_init` before any other log function).
  /// - `-3`: The sink specifier was not UTF-8 encoded.
  /// - `-4`: The sink type specified is not a known type (known types: "stdout", "stderr", "buffer", or "file /some/path").
  /// - `-5`: No file path was specified in a file-type sink specification.
  /// - `-6`: Opening a sink to the specified file path failed (check permissions).
  ///
  /// # Safety
  ///
  /// This function checks the validity of the passed-in sink specifier, and errors
  /// out if the specifier isn't valid UTF-8. Passing in an invalid or NULL pointer will result in
  /// undefined behaviour.
  int pactffi_logger_attach_sink(
    ffi.Pointer<ffi.Char> sink_specifier,
    LevelFilter level_filter,
  ) {
    return _pactffi_logger_attach_sink(
      sink_specifier,
      level_filter.value,
    );
  }

  late final _pactffi_logger_attach_sinkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('pactffi_logger_attach_sink');
  late final _pactffi_logger_attach_sink = _pactffi_logger_attach_sinkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Apply the previously configured sinks and levels to the program. If no sinks have been setup,
  /// will set the log level to info and the target to standard out.
  ///
  /// This function will install a global tracing subscriber. Any attempts to modify the logger
  /// after the call to `logger_apply` will fail.
  ///
  /// # Error Handling
  ///
  /// The return error codes are as follows:
  ///
  /// - `-1`: Can't set logger (applying the logger failed, perhaps because one is applied already).
  int pactffi_logger_apply() {
    return _pactffi_logger_apply();
  }

  late final _pactffi_logger_applyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('pactffi_logger_apply');
  late final _pactffi_logger_apply =
      _pactffi_logger_applyPtr.asFunction<int Function()>();

  /// Fetch the in-memory logger buffer contents. This will only have any contents if the `buffer`
  /// sink has been configured to log to. The contents will be allocated on the heap and will need
  /// to be freed with `pactffi_string_delete`.
  ///
  /// Fetches the logs associated with the provided identifier, or uses the "global" one if the
  /// identifier is not specified (i.e. NULL).
  ///
  /// Returns a NULL pointer if the buffer can't be fetched. This can occur is there is not
  /// sufficient memory to make a copy of the contents or the buffer contains non-UTF-8 characters.
  ///
  /// # Safety
  ///
  /// This function will fail if the log_id pointer is invalid or does not point to a NULL
  /// terminated string.
  ffi.Pointer<ffi.Char> pactffi_fetch_log_buffer(
    ffi.Pointer<ffi.Char> log_id,
  ) {
    return _pactffi_fetch_log_buffer(
      log_id,
    );
  }

  late final _pactffi_fetch_log_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('pactffi_fetch_log_buffer');
  late final _pactffi_fetch_log_buffer = _pactffi_fetch_log_bufferPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Parses the provided JSON into a Pact model. The returned Pact model must be freed with the
  /// `pactffi_pact_model_delete` function when no longer needed.
  ///
  /// # Error Handling
  ///
  /// This function will return a NULL pointer if passed a NULL pointer or if an error occurs.
  ffi.Pointer<Pact> pactffi_parse_pact_json(
    ffi.Pointer<ffi.Char> json,
  ) {
    return _pactffi_parse_pact_json(
      json,
    );
  }

  late final _pactffi_parse_pact_jsonPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<Pact> Function(ffi.Pointer<ffi.Char>)>>(
      'pactffi_parse_pact_json');
  late final _pactffi_parse_pact_json = _pactffi_parse_pact_jsonPtr
      .asFunction<ffi.Pointer<Pact> Function(ffi.Pointer<ffi.Char>)>();

  /// Frees the memory used by the Pact model
  void pactffi_pact_model_delete(
    ffi.Pointer<Pact> pact,
  ) {
    return _pactffi_pact_model_delete(
      pact,
    );
  }

  late final _pactffi_pact_model_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Pact>)>>(
          'pactffi_pact_model_delete');
  late final _pactffi_pact_model_delete = _pactffi_pact_model_deletePtr
      .asFunction<void Function(ffi.Pointer<Pact>)>();

  /// Returns an iterator over all the interactions in the Pact. The iterator will have to be
  /// deleted using the `pactffi_pact_interaction_iter_delete` function. The iterator will
  /// contain a copy of the interactions, so it will not be affected but mutations to the Pact
  /// model and will still function if the Pact model is deleted.
  ///
  /// # Safety
  /// This function is safe as long as the Pact pointer is a valid pointer.
  ///
  /// # Errors
  /// On any error, this function will return a NULL pointer.
  ffi.Pointer<PactInteractionIterator> pactffi_pact_model_interaction_iterator(
    ffi.Pointer<Pact> pact,
  ) {
    return _pactffi_pact_model_interaction_iterator(
      pact,
    );
  }

  late final _pactffi_pact_model_interaction_iteratorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<PactInteractionIterator> Function(
              ffi.Pointer<Pact>)>>('pactffi_pact_model_interaction_iterator');
  late final _pactffi_pact_model_interaction_iterator =
      _pactffi_pact_model_interaction_iteratorPtr.asFunction<
          ffi.Pointer<PactInteractionIterator> Function(ffi.Pointer<Pact>)>();

  /// Returns the Pact specification enum that the Pact is for.
  PactSpecification pactffi_pact_spec_version(
    ffi.Pointer<Pact> pact,
  ) {
    return PactSpecification.fromValue(_pactffi_pact_spec_version(
      pact,
    ));
  }

  late final _pactffi_pact_spec_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<Pact>)>>(
          'pactffi_pact_spec_version');
  late final _pactffi_pact_spec_version = _pactffi_pact_spec_versionPtr
      .asFunction<int Function(ffi.Pointer<Pact>)>();

  /// Frees the memory used by the Pact interaction model
  void pactffi_pact_interaction_delete(
    ffi.Pointer<PactInteraction> interaction,
  ) {
    return _pactffi_pact_interaction_delete(
      interaction,
    );
  }

  late final _pactffi_pact_interaction_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<PactInteraction>)>>(
      'pactffi_pact_interaction_delete');
  late final _pactffi_pact_interaction_delete =
      _pactffi_pact_interaction_deletePtr
          .asFunction<void Function(ffi.Pointer<PactInteraction>)>();

  /// Get a mutable pointer to a newly-created default message on the heap.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// Returns NULL on error.
  ffi.Pointer<AsynchronousMessage> pactffi_async_message_new() {
    return _pactffi_async_message_new();
  }

  late final _pactffi_async_message_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AsynchronousMessage> Function()>>(
          'pactffi_async_message_new');
  late final _pactffi_async_message_new = _pactffi_async_message_newPtr
      .asFunction<ffi.Pointer<AsynchronousMessage> Function()>();

  /// Destroy the `AsynchronousMessage` being pointed to.
  void pactffi_async_message_delete(
    ffi.Pointer<AsynchronousMessage> message,
  ) {
    return _pactffi_async_message_delete(
      message,
    );
  }

  late final _pactffi_async_message_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<AsynchronousMessage>)>>(
      'pactffi_async_message_delete');
  late final _pactffi_async_message_delete = _pactffi_async_message_deletePtr
      .asFunction<void Function(ffi.Pointer<AsynchronousMessage>)>();

  /// Get the message contents of an `AsynchronousMessage` as a `MessageContents` pointer.
  ///
  /// # Safety
  ///
  /// The data pointed to by the pointer this function returns will be deleted when the message
  /// is deleted. Trying to use if after the message is deleted will result in undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL.
  ffi.Pointer<MessageContents> pactffi_async_message_get_contents(
    ffi.Pointer<AsynchronousMessage> message,
  ) {
    return _pactffi_async_message_get_contents(
      message,
    );
  }

  late final _pactffi_async_message_get_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessageContents> Function(
                  ffi.Pointer<AsynchronousMessage>)>>(
      'pactffi_async_message_get_contents');
  late final _pactffi_async_message_get_contents =
      _pactffi_async_message_get_contentsPtr.asFunction<
          ffi.Pointer<MessageContents> Function(
              ffi.Pointer<AsynchronousMessage>)>();

  /// Generate the message contents of an `AsynchronousMessage` as a
  /// `MessageContents` pointer.
  ///
  /// This function differs from [`pactffi_async_message_get_contents`] in
  /// that it will process the message contents for any generators or matchers
  /// that are present in the message in order to generate the actual message
  /// contents as would be received by the consumer.
  ///
  /// # Safety
  ///
  /// The data pointed to by the pointer must be deleted with
  /// [`pactffi_message_contents_delete`][crate::models::contents::pactffi_message_contents_delete]
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL.
  ffi.Pointer<MessageContents> pactffi_async_message_generate_contents(
    ffi.Pointer<AsynchronousMessage> message,
  ) {
    return _pactffi_async_message_generate_contents(
      message,
    );
  }

  late final _pactffi_async_message_generate_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessageContents> Function(
                  ffi.Pointer<AsynchronousMessage>)>>(
      'pactffi_async_message_generate_contents');
  late final _pactffi_async_message_generate_contents =
      _pactffi_async_message_generate_contentsPtr.asFunction<
          ffi.Pointer<MessageContents> Function(
              ffi.Pointer<AsynchronousMessage>)>();

  /// Get the message contents of an `AsynchronousMessage` in string form.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// The returned string can outlive the message.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL. If the body of the message
  /// is missing, then this function also returns NULL. This means there's
  /// no mechanism to differentiate with this function call alone between
  /// a NULL message and a missing message body.
  ffi.Pointer<ffi.Char> pactffi_async_message_get_contents_str(
    ffi.Pointer<AsynchronousMessage> message,
  ) {
    return _pactffi_async_message_get_contents_str(
      message,
    );
  }

  late final _pactffi_async_message_get_contents_strPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<AsynchronousMessage>)>>(
      'pactffi_async_message_get_contents_str');
  late final _pactffi_async_message_get_contents_str =
      _pactffi_async_message_get_contents_strPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<AsynchronousMessage>)>();

  /// Sets the contents of the message as a string.
  ///
  /// * `message` - the message to set the contents for
  /// * `contents` - pointer to contents to copy from. Must be a valid NULL-terminated UTF-8 string pointer.
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The message contents and content type must either be NULL pointers, or point to valid
  /// UTF-8 encoded NULL-terminated strings. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_async_message_set_contents_str(
    ffi.Pointer<AsynchronousMessage> message,
    ffi.Pointer<ffi.Char> contents,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_async_message_set_contents_str(
      message,
      contents,
      content_type,
    );
  }

  late final _pactffi_async_message_set_contents_strPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<AsynchronousMessage>,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>(
      'pactffi_async_message_set_contents_str');
  late final _pactffi_async_message_set_contents_str =
      _pactffi_async_message_set_contents_strPtr.asFunction<
          void Function(ffi.Pointer<AsynchronousMessage>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the length of the contents of a `AsynchronousMessage`.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns 0. If the body of the request
  /// is missing, then this function also returns 0.
  int pactffi_async_message_get_contents_length(
    ffi.Pointer<AsynchronousMessage> message,
  ) {
    return _pactffi_async_message_get_contents_length(
      message,
    );
  }

  late final _pactffi_async_message_get_contents_lengthPtr = _lookup<
          ffi
          .NativeFunction<ffi.Size Function(ffi.Pointer<AsynchronousMessage>)>>(
      'pactffi_async_message_get_contents_length');
  late final _pactffi_async_message_get_contents_length =
      _pactffi_async_message_get_contents_lengthPtr
          .asFunction<int Function(ffi.Pointer<AsynchronousMessage>)>();

  /// Get the contents of an `AsynchronousMessage` as a pointer to an array of bytes.
  ///
  /// # Safety
  ///
  /// The number of bytes in the buffer will be returned by `pactffi_async_message_get_contents_length`.
  /// It is safe to use the pointer while the message is not deleted or changed. Using the pointer
  /// after the message is mutated or deleted may lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL. If the body of the message
  /// is missing, then this function also returns NULL.
  ffi.Pointer<ffi.UnsignedChar> pactffi_async_message_get_contents_bin(
    ffi.Pointer<AsynchronousMessage> message,
  ) {
    return _pactffi_async_message_get_contents_bin(
      message,
    );
  }

  late final _pactffi_async_message_get_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.UnsignedChar> Function(
                  ffi.Pointer<AsynchronousMessage>)>>(
      'pactffi_async_message_get_contents_bin');
  late final _pactffi_async_message_get_contents_bin =
      _pactffi_async_message_get_contents_binPtr.asFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<AsynchronousMessage>)>();

  /// Sets the contents of the message as an array of bytes.
  ///
  /// * `message` - the message to set the contents for
  /// * `contents` - pointer to contents to copy from
  /// * `len` - number of bytes to copy from the contents pointer
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The contents pointer must be valid for reads of `len` bytes, and it must be properly aligned
  /// and consecutive. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_async_message_set_contents_bin(
    ffi.Pointer<AsynchronousMessage> message,
    ffi.Pointer<ffi.UnsignedChar> contents,
    int len,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_async_message_set_contents_bin(
      message,
      contents,
      len,
      content_type,
    );
  }

  late final _pactffi_async_message_set_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<AsynchronousMessage>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>)>>(
      'pactffi_async_message_set_contents_bin');
  late final _pactffi_async_message_set_contents_bin =
      _pactffi_async_message_set_contents_binPtr.asFunction<
          void Function(ffi.Pointer<AsynchronousMessage>,
              ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<ffi.Char>)>();

  /// Get a copy of the description.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// Since it is a copy, the returned string may safely outlive the `AsynchronousMessage`.
  ///
  /// # Errors
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if the Rust string contains embedded
  /// null ('\0') bytes.
  ffi.Pointer<ffi.Char> pactffi_async_message_get_description(
    ffi.Pointer<AsynchronousMessage> message,
  ) {
    return _pactffi_async_message_get_description(
      message,
    );
  }

  late final _pactffi_async_message_get_descriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<AsynchronousMessage>)>>(
      'pactffi_async_message_get_description');
  late final _pactffi_async_message_get_description =
      _pactffi_async_message_get_descriptionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<AsynchronousMessage>)>();

  /// Write the `description` field on the `AsynchronousMessage`.
  ///
  /// # Safety
  ///
  /// `description` must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  ///
  /// This function will only reallocate if the new string
  /// does not fit in the existing buffer.
  ///
  /// # Error Handling
  ///
  /// Errors will be reported with a non-zero return value.
  int pactffi_async_message_set_description(
    ffi.Pointer<AsynchronousMessage> message,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_async_message_set_description(
      message,
      description,
    );
  }

  late final _pactffi_async_message_set_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AsynchronousMessage>,
              ffi.Pointer<ffi.Char>)>>('pactffi_async_message_set_description');
  late final _pactffi_async_message_set_description =
      _pactffi_async_message_set_descriptionPtr.asFunction<
          int Function(
              ffi.Pointer<AsynchronousMessage>, ffi.Pointer<ffi.Char>)>();

  /// Get a copy of the provider state at the given index from this message.
  ///
  /// # Safety
  ///
  /// The returned structure must be deleted with `provider_state_delete`.
  ///
  /// Since it is a copy, the returned structure may safely outlive the `AsynchronousMessage`.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a variant other than Success.
  ///
  /// This function may fail if the index requested is out of bounds,
  /// or if any of the Rust strings contain embedded null ('\0') bytes.
  ffi.Pointer<ProviderState> pactffi_async_message_get_provider_state(
    ffi.Pointer<AsynchronousMessage> message,
    int index,
  ) {
    return _pactffi_async_message_get_provider_state(
      message,
      index,
    );
  }

  late final _pactffi_async_message_get_provider_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ProviderState> Function(ffi.Pointer<AsynchronousMessage>,
              ffi.UnsignedInt)>>('pactffi_async_message_get_provider_state');
  late final _pactffi_async_message_get_provider_state =
      _pactffi_async_message_get_provider_statePtr.asFunction<
          ffi.Pointer<ProviderState> Function(
              ffi.Pointer<AsynchronousMessage>, int)>();

  /// Get an iterator over provider states.
  ///
  /// # Safety
  ///
  /// The underlying data must not change during iteration.
  ///
  /// # Error Handling
  ///
  /// Returns NULL if an error occurs.
  ffi.Pointer<ProviderStateIterator>
      pactffi_async_message_get_provider_state_iter(
    ffi.Pointer<AsynchronousMessage> message,
  ) {
    return _pactffi_async_message_get_provider_state_iter(
      message,
    );
  }

  late final _pactffi_async_message_get_provider_state_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ProviderStateIterator> Function(
                  ffi.Pointer<AsynchronousMessage>)>>(
      'pactffi_async_message_get_provider_state_iter');
  late final _pactffi_async_message_get_provider_state_iter =
      _pactffi_async_message_get_provider_state_iterPtr.asFunction<
          ffi.Pointer<ProviderStateIterator> Function(
              ffi.Pointer<AsynchronousMessage>)>();

  /// Get a copy of this consumer's name.
  ///
  /// The copy must be deleted with `pactffi_string_delete`.
  ///
  /// # Usage
  ///
  /// ```c
  /// // Assuming `file_name` and `json_str` are already defined.
  ///
  /// MessagePact *message_pact = pactffi_message_pact_new_from_json(file_name, json_str);
  /// if (message_pact == NULLPTR) {
  /// // handle error.
  /// }
  ///
  /// Consumer *consumer = pactffi_message_pact_get_consumer(message_pact);
  /// if (consumer == NULLPTR) {
  /// // handle error.
  /// }
  ///
  /// char *name = pactffi_consumer_get_name(consumer);
  /// if (name == NULL) {
  /// // handle error.
  /// }
  ///
  /// printf("%s\n", name);
  ///
  /// pactffi_string_delete(name);
  /// ```
  ///
  /// # Errors
  ///
  /// This function will fail if it is passed a NULL pointer,
  /// or the Rust string contains an embedded NULL byte.
  /// In the case of error, a NULL pointer will be returned.
  ffi.Pointer<ffi.Char> pactffi_consumer_get_name(
    ffi.Pointer<Consumer> consumer,
  ) {
    return _pactffi_consumer_get_name(
      consumer,
    );
  }

  late final _pactffi_consumer_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Consumer>)>>('pactffi_consumer_get_name');
  late final _pactffi_consumer_get_name = _pactffi_consumer_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Consumer>)>();

  /// Get the consumer from a Pact. This returns a copy of the consumer model, and needs to
  /// be cleaned up with `pactffi_pact_consumer_delete` when no longer required.
  ///
  /// # Errors
  ///
  /// This function will fail if it is passed a NULL pointer.
  /// In the case of error, a NULL pointer will be returned.
  ffi.Pointer<Consumer> pactffi_pact_get_consumer(
    ffi.Pointer<Pact> pact,
  ) {
    return _pactffi_pact_get_consumer(
      pact,
    );
  }

  late final _pactffi_pact_get_consumerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<Consumer> Function(ffi.Pointer<Pact>)>>(
      'pactffi_pact_get_consumer');
  late final _pactffi_pact_get_consumer = _pactffi_pact_get_consumerPtr
      .asFunction<ffi.Pointer<Consumer> Function(ffi.Pointer<Pact>)>();

  /// Frees the memory used by the Pact consumer
  void pactffi_pact_consumer_delete(
    ffi.Pointer<Consumer> consumer,
  ) {
    return _pactffi_pact_consumer_delete(
      consumer,
    );
  }

  late final _pactffi_pact_consumer_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Consumer>)>>(
          'pactffi_pact_consumer_delete');
  late final _pactffi_pact_consumer_delete = _pactffi_pact_consumer_deletePtr
      .asFunction<void Function(ffi.Pointer<Consumer>)>();

  /// Delete the message contents instance.
  ///
  /// # Safety
  ///
  /// This should only be called on a message contents that require deletion.
  /// The function creating the message contents should document whether it
  /// requires deletion.
  ///
  /// Deleting a message content which is associated with an interaction
  /// will result in undefined behaviour.
  void pactffi_message_contents_delete(
    ffi.Pointer<MessageContents> contents,
  ) {
    return _pactffi_message_contents_delete(
      contents,
    );
  }

  late final _pactffi_message_contents_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MessageContents>)>>(
      'pactffi_message_contents_delete');
  late final _pactffi_message_contents_delete =
      _pactffi_message_contents_deletePtr
          .asFunction<void Function(ffi.Pointer<MessageContents>)>();

  /// Get the message contents in string form.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// The returned string can outlive the message.
  ///
  /// # Error Handling
  ///
  /// If the message contents is NULL, returns NULL. If the body of the message
  /// is missing, then this function also returns NULL. This means there's
  /// no mechanism to differentiate with this function call alone between
  /// a NULL message and a missing message body.
  ffi.Pointer<ffi.Char> pactffi_message_contents_get_contents_str(
    ffi.Pointer<MessageContents> contents,
  ) {
    return _pactffi_message_contents_get_contents_str(
      contents,
    );
  }

  late final _pactffi_message_contents_get_contents_strPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<MessageContents>)>>(
      'pactffi_message_contents_get_contents_str');
  late final _pactffi_message_contents_get_contents_str =
      _pactffi_message_contents_get_contents_strPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MessageContents>)>();

  /// Sets the contents of the message as a string.
  ///
  /// * `contents` - the message contents to set the contents for
  /// * `contents_str` - pointer to contents to copy from. Must be a valid NULL-terminated UTF-8 string pointer.
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The message contents and content type must either be NULL pointers, or point to valid
  /// UTF-8 encoded NULL-terminated strings. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents string is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_message_contents_set_contents_str(
    ffi.Pointer<MessageContents> contents,
    ffi.Pointer<ffi.Char> contents_str,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_message_contents_set_contents_str(
      contents,
      contents_str,
      content_type,
    );
  }

  late final _pactffi_message_contents_set_contents_strPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MessageContents>,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>(
      'pactffi_message_contents_set_contents_str');
  late final _pactffi_message_contents_set_contents_str =
      _pactffi_message_contents_set_contents_strPtr.asFunction<
          void Function(ffi.Pointer<MessageContents>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the length of the message contents.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns 0. If the body of the message
  /// is missing, then this function also returns 0.
  int pactffi_message_contents_get_contents_length(
    ffi.Pointer<MessageContents> contents,
  ) {
    return _pactffi_message_contents_get_contents_length(
      contents,
    );
  }

  late final _pactffi_message_contents_get_contents_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<MessageContents>)>>(
      'pactffi_message_contents_get_contents_length');
  late final _pactffi_message_contents_get_contents_length =
      _pactffi_message_contents_get_contents_lengthPtr
          .asFunction<int Function(ffi.Pointer<MessageContents>)>();

  /// Get the contents of a message as a pointer to an array of bytes.
  ///
  /// # Safety
  ///
  /// The number of bytes in the buffer will be returned by `pactffi_message_contents_get_contents_length`.
  /// It is safe to use the pointer while the message is not deleted or changed. Using the pointer
  /// after the message is mutated or deleted may lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL. If the body of the message
  /// is missing, then this function also returns NULL.
  ffi.Pointer<ffi.UnsignedChar> pactffi_message_contents_get_contents_bin(
    ffi.Pointer<MessageContents> contents,
  ) {
    return _pactffi_message_contents_get_contents_bin(
      contents,
    );
  }

  late final _pactffi_message_contents_get_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.UnsignedChar> Function(
                  ffi.Pointer<MessageContents>)>>(
      'pactffi_message_contents_get_contents_bin');
  late final _pactffi_message_contents_get_contents_bin =
      _pactffi_message_contents_get_contents_binPtr.asFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<MessageContents>)>();

  /// Sets the contents of the message as an array of bytes.
  ///
  /// * `message` - the message contents to set the contents for
  /// * `contents_bin` - pointer to contents to copy from
  /// * `len` - number of bytes to copy from the contents pointer
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The contents pointer must be valid for reads of `len` bytes, and it must be properly aligned
  /// and consecutive. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_message_contents_set_contents_bin(
    ffi.Pointer<MessageContents> contents,
    ffi.Pointer<ffi.UnsignedChar> contents_bin,
    int len,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_message_contents_set_contents_bin(
      contents,
      contents_bin,
      len,
      content_type,
    );
  }

  late final _pactffi_message_contents_set_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<MessageContents>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>)>>(
      'pactffi_message_contents_set_contents_bin');
  late final _pactffi_message_contents_set_contents_bin =
      _pactffi_message_contents_set_contents_binPtr.asFunction<
          void Function(ffi.Pointer<MessageContents>,
              ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<ffi.Char>)>();

  /// Get an iterator over the metadata of a message.
  ///
  /// The returned pointer must be deleted with `pactffi_message_metadata_iter_delete` when done
  /// with it.
  ///
  /// # Safety
  ///
  /// This iterator carries a pointer to the message contents, and must
  /// not outlive the message.
  ///
  /// The message metadata also must not be modified during iteration. If it is,
  /// the old iterator must be deleted and a new iterator created.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain
  /// embedded null ('\0') bytes.
  ffi.Pointer<MessageMetadataIterator>
      pactffi_message_contents_get_metadata_iter(
    ffi.Pointer<MessageContents> contents,
  ) {
    return _pactffi_message_contents_get_metadata_iter(
      contents,
    );
  }

  late final _pactffi_message_contents_get_metadata_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessageMetadataIterator> Function(
                  ffi.Pointer<MessageContents>)>>(
      'pactffi_message_contents_get_metadata_iter');
  late final _pactffi_message_contents_get_metadata_iter =
      _pactffi_message_contents_get_metadata_iterPtr.asFunction<
          ffi.Pointer<MessageMetadataIterator> Function(
              ffi.Pointer<MessageContents>)>();

  /// Get an iterator over the matching rules for a category of a message.
  ///
  /// The returned pointer must be deleted with `pactffi_matching_rules_iter_delete` when done
  /// with it.
  ///
  /// Note that there could be multiple matching rules for the same key, so this iterator will
  /// sequentially return each rule with the same key.
  ///
  /// For sample, given the following rules:
  /// "$.a" => Type,
  /// "$.b" => Regex("\\d+"), Number
  ///
  /// This iterator will return a sequence of 3 values: ("$.a", Type), ("$.b", Regex("\\d+")), ("$.b", Number)
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the data, so is safe to use when the message or message
  /// contents has been deleted.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ffi.Pointer<MatchingRuleCategoryIterator>
      pactffi_message_contents_get_matching_rule_iter(
    ffi.Pointer<MessageContents> contents,
    MatchingRuleCategory category,
  ) {
    return _pactffi_message_contents_get_matching_rule_iter(
      contents,
      category.value,
    );
  }

  late final _pactffi_message_contents_get_matching_rule_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MatchingRuleCategoryIterator> Function(
                  ffi.Pointer<MessageContents>, ffi.UnsignedInt)>>(
      'pactffi_message_contents_get_matching_rule_iter');
  late final _pactffi_message_contents_get_matching_rule_iter =
      _pactffi_message_contents_get_matching_rule_iterPtr.asFunction<
          ffi.Pointer<MatchingRuleCategoryIterator> Function(
              ffi.Pointer<MessageContents>, int)>();

  /// Get an iterator over the matching rules for a category of an HTTP request.
  ///
  /// The returned pointer must be deleted with `pactffi_matching_rules_iter_delete` when done
  /// with it.
  ///
  /// For sample, given the following rules:
  /// "$.a" => Type,
  /// "$.b" => Regex("\\d+"), Number
  ///
  /// This iterator will return a sequence of 3 values: ("$.a", Type), ("$.b", Regex("\\d+")), ("$.b", Number)
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the data, so is safe to use when the interaction or request
  /// contents has been deleted.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ffi.Pointer<MatchingRuleCategoryIterator>
      pactffi_request_contents_get_matching_rule_iter(
    ffi.Pointer<HttpRequest> request,
    MatchingRuleCategory category,
  ) {
    return _pactffi_request_contents_get_matching_rule_iter(
      request,
      category.value,
    );
  }

  late final _pactffi_request_contents_get_matching_rule_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MatchingRuleCategoryIterator> Function(
                  ffi.Pointer<HttpRequest>, ffi.UnsignedInt)>>(
      'pactffi_request_contents_get_matching_rule_iter');
  late final _pactffi_request_contents_get_matching_rule_iter =
      _pactffi_request_contents_get_matching_rule_iterPtr.asFunction<
          ffi.Pointer<MatchingRuleCategoryIterator> Function(
              ffi.Pointer<HttpRequest>, int)>();

  /// Get an iterator over the matching rules for a category of an HTTP response.
  ///
  /// The returned pointer must be deleted with `pactffi_matching_rules_iter_delete` when done
  /// with it.
  ///
  /// For sample, given the following rules:
  /// "$.a" => Type,
  /// "$.b" => Regex("\\d+"), Number
  ///
  /// This iterator will return a sequence of 3 values: ("$.a", Type), ("$.b", Regex("\\d+")), ("$.b", Number)
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the data, so is safe to use when the interaction or response
  /// contents has been deleted.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ffi.Pointer<MatchingRuleCategoryIterator>
      pactffi_response_contents_get_matching_rule_iter(
    ffi.Pointer<HttpResponse> response,
    MatchingRuleCategory category,
  ) {
    return _pactffi_response_contents_get_matching_rule_iter(
      response,
      category.value,
    );
  }

  late final _pactffi_response_contents_get_matching_rule_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MatchingRuleCategoryIterator> Function(
                  ffi.Pointer<HttpResponse>, ffi.UnsignedInt)>>(
      'pactffi_response_contents_get_matching_rule_iter');
  late final _pactffi_response_contents_get_matching_rule_iter =
      _pactffi_response_contents_get_matching_rule_iterPtr.asFunction<
          ffi.Pointer<MatchingRuleCategoryIterator> Function(
              ffi.Pointer<HttpResponse>, int)>();

  /// Get an iterator over the generators for a category of a message.
  ///
  /// The returned pointer must be deleted with `pactffi_generators_iter_delete` when done
  /// with it.
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the data, so is safe to use when the message or message
  /// contents has been deleted.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ffi.Pointer<GeneratorCategoryIterator>
      pactffi_message_contents_get_generators_iter(
    ffi.Pointer<MessageContents> contents,
    GeneratorCategory category,
  ) {
    return _pactffi_message_contents_get_generators_iter(
      contents,
      category.value,
    );
  }

  late final _pactffi_message_contents_get_generators_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GeneratorCategoryIterator> Function(
                  ffi.Pointer<MessageContents>, ffi.UnsignedInt)>>(
      'pactffi_message_contents_get_generators_iter');
  late final _pactffi_message_contents_get_generators_iter =
      _pactffi_message_contents_get_generators_iterPtr.asFunction<
          ffi.Pointer<GeneratorCategoryIterator> Function(
              ffi.Pointer<MessageContents>, int)>();

  /// Get an iterator over the generators for a category of an HTTP request.
  ///
  /// The returned pointer must be deleted with `pactffi_generators_iter_delete` when done
  /// with it.
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the data, so is safe to use when the interaction or request
  /// contents has been deleted.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ffi.Pointer<GeneratorCategoryIterator>
      pactffi_request_contents_get_generators_iter(
    ffi.Pointer<HttpRequest> request,
    GeneratorCategory category,
  ) {
    return _pactffi_request_contents_get_generators_iter(
      request,
      category.value,
    );
  }

  late final _pactffi_request_contents_get_generators_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GeneratorCategoryIterator> Function(
                  ffi.Pointer<HttpRequest>, ffi.UnsignedInt)>>(
      'pactffi_request_contents_get_generators_iter');
  late final _pactffi_request_contents_get_generators_iter =
      _pactffi_request_contents_get_generators_iterPtr.asFunction<
          ffi.Pointer<GeneratorCategoryIterator> Function(
              ffi.Pointer<HttpRequest>, int)>();

  /// Get an iterator over the generators for a category of an HTTP response.
  ///
  /// The returned pointer must be deleted with `pactffi_generators_iter_delete` when done
  /// with it.
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the data, so is safe to use when the interaction or response
  /// contents has been deleted.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ffi.Pointer<GeneratorCategoryIterator>
      pactffi_response_contents_get_generators_iter(
    ffi.Pointer<HttpResponse> response,
    GeneratorCategory category,
  ) {
    return _pactffi_response_contents_get_generators_iter(
      response,
      category.value,
    );
  }

  late final _pactffi_response_contents_get_generators_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GeneratorCategoryIterator> Function(
                  ffi.Pointer<HttpResponse>, ffi.UnsignedInt)>>(
      'pactffi_response_contents_get_generators_iter');
  late final _pactffi_response_contents_get_generators_iter =
      _pactffi_response_contents_get_generators_iterPtr.asFunction<
          ffi.Pointer<GeneratorCategoryIterator> Function(
              ffi.Pointer<HttpResponse>, int)>();

  /// Parse a matcher definition string into a MatchingRuleDefinition containing the example value,
  /// and matching rules and any generator.
  ///
  /// The following are examples of matching rule definitions:
  /// * `matching(type,'Name')` - type matcher with string value 'Name'
  /// * `matching(number,100)` - number matcher
  /// * `matching(datetime, 'yyyy-MM-dd','2000-01-01')` - datetime matcher with format string
  ///
  /// See [Matching Rule definition expressions](https://docs.rs/pact_models/latest/pact_models/matchingrules/expressions/index.html).
  ///
  /// The returned value needs to be freed up with the `pactffi_matcher_definition_delete` function.
  ///
  /// # Errors
  /// If the expression is invalid, the MatchingRuleDefinition error will be set. You can check for
  /// this value with the `pactffi_matcher_definition_error` function.
  ///
  /// # Safety
  ///
  /// This function is safe if the expression is a valid NULL terminated string pointer.
  ffi.Pointer<MatchingRuleDefinitionResult> pactffi_parse_matcher_definition(
    ffi.Pointer<ffi.Char> expression,
  ) {
    return _pactffi_parse_matcher_definition(
      expression,
    );
  }

  late final _pactffi_parse_matcher_definitionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<MatchingRuleDefinitionResult> Function(
              ffi.Pointer<ffi.Char>)>>('pactffi_parse_matcher_definition');
  late final _pactffi_parse_matcher_definition =
      _pactffi_parse_matcher_definitionPtr.asFunction<
          ffi.Pointer<MatchingRuleDefinitionResult> Function(
              ffi.Pointer<ffi.Char>)>();

  /// Returns any error message from parsing a matching definition expression. If there is no error,
  /// it will return a NULL pointer, otherwise returns the error message as a NULL-terminated string.
  /// The returned string must be freed using the `pactffi_string_delete` function once done with it.
  ffi.Pointer<ffi.Char> pactffi_matcher_definition_error(
    ffi.Pointer<MatchingRuleDefinitionResult> definition,
  ) {
    return _pactffi_matcher_definition_error(
      definition,
    );
  }

  late final _pactffi_matcher_definition_errorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<MatchingRuleDefinitionResult>)>>(
      'pactffi_matcher_definition_error');
  late final _pactffi_matcher_definition_error =
      _pactffi_matcher_definition_errorPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRuleDefinitionResult>)>();

  /// Returns the value from parsing a matching definition expression. If there was an error,
  /// it will return a NULL pointer, otherwise returns the value as a NULL-terminated string.
  /// The returned string must be freed using the `pactffi_string_delete` function once done with it.
  ///
  /// Note that different expressions values can have types other than a string. Use
  /// `pactffi_matcher_definition_value_type` to get the actual type of the value. This function
  /// will always return the string representation of the value.
  ffi.Pointer<ffi.Char> pactffi_matcher_definition_value(
    ffi.Pointer<MatchingRuleDefinitionResult> definition,
  ) {
    return _pactffi_matcher_definition_value(
      definition,
    );
  }

  late final _pactffi_matcher_definition_valuePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<MatchingRuleDefinitionResult>)>>(
      'pactffi_matcher_definition_value');
  late final _pactffi_matcher_definition_value =
      _pactffi_matcher_definition_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRuleDefinitionResult>)>();

  /// Frees the memory used by the result of parsing the matching definition expression
  void pactffi_matcher_definition_delete(
    ffi.Pointer<MatchingRuleDefinitionResult> definition,
  ) {
    return _pactffi_matcher_definition_delete(
      definition,
    );
  }

  late final _pactffi_matcher_definition_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MatchingRuleDefinitionResult>)>>(
      'pactffi_matcher_definition_delete');
  late final _pactffi_matcher_definition_delete =
      _pactffi_matcher_definition_deletePtr.asFunction<
          void Function(ffi.Pointer<MatchingRuleDefinitionResult>)>();

  /// Returns the generator from parsing a matching definition expression. If there was an error or
  /// there is no associated generator, it will return a NULL pointer, otherwise returns the generator
  /// as a pointer.
  ///
  /// The generator pointer will be a valid pointer as long as `pactffi_matcher_definition_delete`
  /// has not been called on the definition. Using the generator pointer after the definition
  /// has been deleted will result in undefined behaviour.
  ffi.Pointer<Generator> pactffi_matcher_definition_generator(
    ffi.Pointer<MatchingRuleDefinitionResult> definition,
  ) {
    return _pactffi_matcher_definition_generator(
      definition,
    );
  }

  late final _pactffi_matcher_definition_generatorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<Generator> Function(
                  ffi.Pointer<MatchingRuleDefinitionResult>)>>(
      'pactffi_matcher_definition_generator');
  late final _pactffi_matcher_definition_generator =
      _pactffi_matcher_definition_generatorPtr.asFunction<
          ffi.Pointer<Generator> Function(
              ffi.Pointer<MatchingRuleDefinitionResult>)>();

  /// Returns the type of the value from parsing a matching definition expression. If there was an
  /// error parsing the expression, it will return Unknown.
  ExpressionValueType pactffi_matcher_definition_value_type(
    ffi.Pointer<MatchingRuleDefinitionResult> definition,
  ) {
    return ExpressionValueType.fromValue(_pactffi_matcher_definition_value_type(
      definition,
    ));
  }

  late final _pactffi_matcher_definition_value_typePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  ffi.Pointer<MatchingRuleDefinitionResult>)>>(
      'pactffi_matcher_definition_value_type');
  late final _pactffi_matcher_definition_value_type =
      _pactffi_matcher_definition_value_typePtr.asFunction<
          int Function(ffi.Pointer<MatchingRuleDefinitionResult>)>();

  /// Free the iterator when you're done using it.
  void pactffi_matching_rule_iter_delete(
    ffi.Pointer<MatchingRuleIterator> iter,
  ) {
    return _pactffi_matching_rule_iter_delete(
      iter,
    );
  }

  late final _pactffi_matching_rule_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MatchingRuleIterator>)>>(
      'pactffi_matching_rule_iter_delete');
  late final _pactffi_matching_rule_iter_delete =
      _pactffi_matching_rule_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<MatchingRuleIterator>)>();

  /// Returns an iterator over the matching rules from the parsed definition. The iterator needs to
  /// be deleted with the `pactffi_matching_rule_iter_delete` function once done with it.
  ///
  /// If there was an error parsing the expression, this function will return a NULL pointer.
  ffi.Pointer<MatchingRuleIterator> pactffi_matcher_definition_iter(
    ffi.Pointer<MatchingRuleDefinitionResult> definition,
  ) {
    return _pactffi_matcher_definition_iter(
      definition,
    );
  }

  late final _pactffi_matcher_definition_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MatchingRuleIterator> Function(
                  ffi.Pointer<MatchingRuleDefinitionResult>)>>(
      'pactffi_matcher_definition_iter');
  late final _pactffi_matcher_definition_iter =
      _pactffi_matcher_definition_iterPtr.asFunction<
          ffi.Pointer<MatchingRuleIterator> Function(
              ffi.Pointer<MatchingRuleDefinitionResult>)>();

  /// Get the next matching rule or reference from the iterator. As the values returned are owned
  /// by the iterator, they do not need to be deleted but will be cleaned up when the iterator is
  /// deleted.
  ///
  /// Will return a NULL pointer when the iterator has advanced past the end of the list.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// This function will return a NULL pointer if passed a NULL pointer or if an error occurs.
  ffi.Pointer<MatchingRuleResult> pactffi_matching_rule_iter_next(
    ffi.Pointer<MatchingRuleIterator> iter,
  ) {
    return _pactffi_matching_rule_iter_next(
      iter,
    );
  }

  late final _pactffi_matching_rule_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MatchingRuleResult> Function(
                  ffi.Pointer<MatchingRuleIterator>)>>(
      'pactffi_matching_rule_iter_next');
  late final _pactffi_matching_rule_iter_next =
      _pactffi_matching_rule_iter_nextPtr.asFunction<
          ffi.Pointer<MatchingRuleResult> Function(
              ffi.Pointer<MatchingRuleIterator>)>();

  /// Return the ID of the matching rule.
  ///
  /// The ID corresponds to the following rules:
  /// | Rule | ID |
  /// | ---- | -- |
  /// | Equality | 1 |
  /// | Regex | 2 |
  /// | Type | 3 |
  /// | MinType | 4 |
  /// | MaxType | 5 |
  /// | MinMaxType | 6 |
  /// | Timestamp | 7 |
  /// | Time | 8 |
  /// | Date | 9 |
  /// | Include | 10 |
  /// | Number | 11 |
  /// | Integer | 12 |
  /// | Decimal | 13 |
  /// | Null | 14 |
  /// | ContentType | 15 |
  /// | ArrayContains | 16 |
  /// | Values | 17 |
  /// | Boolean | 18 |
  /// | StatusCode | 19 |
  /// | NotEmpty | 20 |
  /// | Semver | 21 |
  /// | EachKey | 22 |
  /// | EachValue | 23 |
  ///
  /// # Safety
  ///
  /// This function is safe as long as the MatchingRuleResult pointer is a valid pointer and the
  /// iterator has not been deleted.
  int pactffi_matching_rule_id(
    ffi.Pointer<MatchingRuleResult> rule_result,
  ) {
    return _pactffi_matching_rule_id(
      rule_result,
    );
  }

  late final _pactffi_matching_rule_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint16 Function(
              ffi.Pointer<MatchingRuleResult>)>>('pactffi_matching_rule_id');
  late final _pactffi_matching_rule_id = _pactffi_matching_rule_idPtr
      .asFunction<int Function(ffi.Pointer<MatchingRuleResult>)>();

  /// Returns the associated value for the matching rule. If the matching rule does not have an
  /// associated value, will return a NULL pointer.
  ///
  /// The associated values for the rules are:
  /// | Rule | ID | VALUE |
  /// | ---- | -- | ----- |
  /// | Equality | 1 | NULL |
  /// | Regex | 2 | Regex value |
  /// | Type | 3 | NULL |
  /// | MinType | 4 | Minimum value |
  /// | MaxType | 5 | Maximum value |
  /// | MinMaxType | 6 | "min:max" |
  /// | Timestamp | 7 | Format string |
  /// | Time | 8 | Format string |
  /// | Date | 9 | Format string |
  /// | Include | 10 | String value |
  /// | Number | 11 | NULL |
  /// | Integer | 12 | NULL |
  /// | Decimal | 13 | NULL |
  /// | Null | 14 | NULL |
  /// | ContentType | 15 | Content type |
  /// | ArrayContains | 16 | NULL |
  /// | Values | 17 | NULL |
  /// | Boolean | 18 | NULL |
  /// | StatusCode | 19 | NULL |
  /// | NotEmpty | 20 | NULL |
  /// | Semver | 21 | NULL |
  /// | EachKey | 22 | NULL |
  /// | EachValue | 23 | NULL |
  ///
  /// Will return a NULL pointer if the matching rule was a reference or does not have an
  /// associated value.
  ///
  /// # Safety
  ///
  /// This function is safe as long as the MatchingRuleResult pointer is a valid pointer and the
  /// iterator it came from has not been deleted.
  ffi.Pointer<ffi.Char> pactffi_matching_rule_value(
    ffi.Pointer<MatchingRuleResult> rule_result,
  ) {
    return _pactffi_matching_rule_value(
      rule_result,
    );
  }

  late final _pactffi_matching_rule_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRuleResult>)>>('pactffi_matching_rule_value');
  late final _pactffi_matching_rule_value =
      _pactffi_matching_rule_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRuleResult>)>();

  /// Returns the matching rule pointer for the matching rule. Will return a NULL pointer if the
  /// matching rule result was a reference.
  ///
  /// # Safety
  ///
  /// This function is safe as long as the MatchingRuleResult pointer is a valid pointer and the
  /// iterator it came from has not been deleted.
  ffi.Pointer<MatchingRule> pactffi_matching_rule_pointer(
    ffi.Pointer<MatchingRuleResult> rule_result,
  ) {
    return _pactffi_matching_rule_pointer(
      rule_result,
    );
  }

  late final _pactffi_matching_rule_pointerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MatchingRule> Function(
                  ffi.Pointer<MatchingRuleResult>)>>(
      'pactffi_matching_rule_pointer');
  late final _pactffi_matching_rule_pointer =
      _pactffi_matching_rule_pointerPtr.asFunction<
          ffi.Pointer<MatchingRule> Function(
              ffi.Pointer<MatchingRuleResult>)>();

  /// Return any matching rule reference to a attribute by name. This is when the matcher should
  /// be configured to match the type of a structure. I.e.,
  ///
  /// ```json
  /// {
  /// "pact:match": "eachValue(matching($'person'))",
  /// "person": {
  /// "name": "Fred",
  /// "age": 100
  /// }
  /// }
  /// ```
  ///
  /// Will return a NULL pointer if the matching rule was not a reference.
  ///
  /// # Safety
  ///
  /// This function is safe as long as the MatchingRuleResult pointer is a valid pointer and the
  /// iterator has not been deleted.
  ffi.Pointer<ffi.Char> pactffi_matching_rule_reference_name(
    ffi.Pointer<MatchingRuleResult> rule_result,
  ) {
    return _pactffi_matching_rule_reference_name(
      rule_result,
    );
  }

  late final _pactffi_matching_rule_reference_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRuleResult>)>>(
      'pactffi_matching_rule_reference_name');
  late final _pactffi_matching_rule_reference_name =
      _pactffi_matching_rule_reference_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRuleResult>)>();

  /// Validates the date/time value against the date/time format string. If the value is valid,
  /// this function will return a zero status code (EXIT_SUCCESS).
  /// If the value is not valid, will return a value of 1 (EXIT_FAILURE) and set the
  /// error message which can be retrieved with `pactffi_get_error_message`.
  ///
  /// # Errors
  /// If the function receives a panic, it will return 2 and the message associated with the
  /// panic can be retrieved with `pactffi_get_error_message`.
  ///
  /// # Safety
  ///
  /// This function is safe as long as the value and format parameters point to valid
  /// NULL-terminated strings.
  int pactffi_validate_datetime(
    ffi.Pointer<ffi.Char> value,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _pactffi_validate_datetime(
      value,
      format,
    );
  }

  late final _pactffi_validate_datetimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_validate_datetime');
  late final _pactffi_validate_datetime = _pactffi_validate_datetimePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Get the JSON form of the generator.
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// # Safety
  ///
  /// This function will fail if it is passed a NULL pointer, or the owner of the generator has
  /// been deleted.
  ffi.Pointer<ffi.Char> pactffi_generator_to_json(
    ffi.Pointer<Generator> generator,
  ) {
    return _pactffi_generator_to_json(
      generator,
    );
  }

  late final _pactffi_generator_to_jsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Generator>)>>('pactffi_generator_to_json');
  late final _pactffi_generator_to_json = _pactffi_generator_to_jsonPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Generator>)>();

  /// Generate a string value using the provided generator and an optional JSON payload containing
  /// any generator context. The context value is used for generators like `MockServerURL` (which
  /// should contain details about the running mock server) and `ProviderStateGenerator` (which
  /// should be the values returned from the Provider State callback function).
  ///
  /// If anything goes wrong, it will return a NULL pointer.
  ffi.Pointer<ffi.Char> pactffi_generator_generate_string(
    ffi.Pointer<Generator> generator,
    ffi.Pointer<ffi.Char> context_json,
  ) {
    return _pactffi_generator_generate_string(
      generator,
      context_json,
    );
  }

  late final _pactffi_generator_generate_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<Generator>,
              ffi.Pointer<ffi.Char>)>>('pactffi_generator_generate_string');
  late final _pactffi_generator_generate_string =
      _pactffi_generator_generate_stringPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Generator>, ffi.Pointer<ffi.Char>)>();

  /// Generate an integer value using the provided generator and an optional JSON payload containing
  /// any generator context. The context value is used for generators like `ProviderStateGenerator`
  /// (which should be the values returned from the Provider State callback function).
  ///
  /// If anything goes wrong or the generator is not a type that can generate an integer value, it
  /// will return a zero value.
  int pactffi_generator_generate_integer(
    ffi.Pointer<Generator> generator,
    ffi.Pointer<ffi.Char> context_json,
  ) {
    return _pactffi_generator_generate_integer(
      generator,
      context_json,
    );
  }

  late final _pactffi_generator_generate_integerPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedShort Function(ffi.Pointer<Generator>,
              ffi.Pointer<ffi.Char>)>>('pactffi_generator_generate_integer');
  late final _pactffi_generator_generate_integer =
      _pactffi_generator_generate_integerPtr.asFunction<
          int Function(ffi.Pointer<Generator>, ffi.Pointer<ffi.Char>)>();

  /// Free the iterator when you're done using it.
  void pactffi_generators_iter_delete(
    ffi.Pointer<GeneratorCategoryIterator> iter,
  ) {
    return _pactffi_generators_iter_delete(
      iter,
    );
  }

  late final _pactffi_generators_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GeneratorCategoryIterator>)>>(
      'pactffi_generators_iter_delete');
  late final _pactffi_generators_iter_delete =
      _pactffi_generators_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<GeneratorCategoryIterator>)>();

  /// Get the next path and generator out of the iterator, if possible.
  ///
  /// The returned pointer must be deleted with `pactffi_generator_iter_pair_delete`.
  ///
  /// # Safety
  ///
  /// The underlying data is owned by the `GeneratorKeyValuePair`, so is always safe to use.
  ///
  /// # Error Handling
  ///
  /// If no further data is present, returns NULL.
  ffi.Pointer<GeneratorKeyValuePair> pactffi_generators_iter_next(
    ffi.Pointer<GeneratorCategoryIterator> iter,
  ) {
    return _pactffi_generators_iter_next(
      iter,
    );
  }

  late final _pactffi_generators_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GeneratorKeyValuePair> Function(
                  ffi.Pointer<GeneratorCategoryIterator>)>>(
      'pactffi_generators_iter_next');
  late final _pactffi_generators_iter_next =
      _pactffi_generators_iter_nextPtr.asFunction<
          ffi.Pointer<GeneratorKeyValuePair> Function(
              ffi.Pointer<GeneratorCategoryIterator>)>();

  /// Free a pair of key and value returned from `pactffi_generators_iter_next`.
  void pactffi_generators_iter_pair_delete(
    ffi.Pointer<GeneratorKeyValuePair> pair,
  ) {
    return _pactffi_generators_iter_pair_delete(
      pair,
    );
  }

  late final _pactffi_generators_iter_pair_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GeneratorKeyValuePair>)>>(
      'pactffi_generators_iter_pair_delete');
  late final _pactffi_generators_iter_pair_delete =
      _pactffi_generators_iter_pair_deletePtr
          .asFunction<void Function(ffi.Pointer<GeneratorKeyValuePair>)>();

  /// Get a mutable pointer to a newly-created default interaction on the heap.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// Returns NULL on error.
  ffi.Pointer<SynchronousHttp> pactffi_sync_http_new() {
    return _pactffi_sync_http_new();
  }

  late final _pactffi_sync_http_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SynchronousHttp> Function()>>(
          'pactffi_sync_http_new');
  late final _pactffi_sync_http_new = _pactffi_sync_http_newPtr
      .asFunction<ffi.Pointer<SynchronousHttp> Function()>();

  /// Destroy the `SynchronousHttp` interaction being pointed to.
  void pactffi_sync_http_delete(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_delete(
      interaction,
    );
  }

  late final _pactffi_sync_http_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_delete');
  late final _pactffi_sync_http_delete = _pactffi_sync_http_deletePtr
      .asFunction<void Function(ffi.Pointer<SynchronousHttp>)>();

  /// Get the request of a `SynchronousHttp` interaction.
  ///
  /// # Safety
  ///
  /// The data pointed to by the pointer this function returns will be deleted when the interaction
  /// is deleted. Trying to use if after the interaction is deleted will result in undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the interaction is NULL, returns NULL.
  ffi.Pointer<HttpRequest> pactffi_sync_http_get_request(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_request(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_requestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<HttpRequest> Function(
              ffi.Pointer<SynchronousHttp>)>>('pactffi_sync_http_get_request');
  late final _pactffi_sync_http_get_request =
      _pactffi_sync_http_get_requestPtr.asFunction<
          ffi.Pointer<HttpRequest> Function(ffi.Pointer<SynchronousHttp>)>();

  /// Get the request contents of a `SynchronousHttp` interaction in string form.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// The returned string can outlive the interaction.
  ///
  /// # Error Handling
  ///
  /// If the interaction is NULL, returns NULL. If the body of the request
  /// is missing, then this function also returns NULL. This means there's
  /// no mechanism to differentiate with this function call alone between
  /// a NULL body and a missing body.
  ffi.Pointer<ffi.Char> pactffi_sync_http_get_request_contents(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_request_contents(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_request_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_get_request_contents');
  late final _pactffi_sync_http_get_request_contents =
      _pactffi_sync_http_get_request_contentsPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousHttp>)>();

  /// Sets the request contents of the interaction.
  ///
  /// * `interaction` - the interaction to set the request contents for
  /// * `contents` - pointer to contents to copy from. Must be a valid NULL-terminated UTF-8 string pointer.
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The request contents and content type must either be NULL pointers, or point to valid
  /// UTF-8 encoded NULL-terminated strings. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the request contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_sync_http_set_request_contents(
    ffi.Pointer<SynchronousHttp> interaction,
    ffi.Pointer<ffi.Char> contents,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_sync_http_set_request_contents(
      interaction,
      contents,
      content_type,
    );
  }

  late final _pactffi_sync_http_set_request_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SynchronousHttp>,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>(
      'pactffi_sync_http_set_request_contents');
  late final _pactffi_sync_http_set_request_contents =
      _pactffi_sync_http_set_request_contentsPtr.asFunction<
          void Function(ffi.Pointer<SynchronousHttp>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the length of the request contents of a `SynchronousHttp` interaction.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the interaction is NULL, returns 0. If the body of the request
  /// is missing, then this function also returns 0.
  int pactffi_sync_http_get_request_contents_length(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_request_contents_length(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_request_contents_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_get_request_contents_length');
  late final _pactffi_sync_http_get_request_contents_length =
      _pactffi_sync_http_get_request_contents_lengthPtr
          .asFunction<int Function(ffi.Pointer<SynchronousHttp>)>();

  /// Get the request contents of a `SynchronousHttp` interaction as a pointer to an array of bytes.
  ///
  /// # Safety
  ///
  /// The number of bytes in the buffer will be returned by `pactffi_sync_http_get_request_contents_length`.
  /// It is safe to use the pointer while the interaction is not deleted or changed. Using the pointer
  /// after the interaction is mutated or deleted may lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the interaction is NULL, returns NULL. If the body of the request
  /// is missing, then this function also returns NULL.
  ffi.Pointer<ffi.UnsignedChar> pactffi_sync_http_get_request_contents_bin(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_request_contents_bin(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_request_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.UnsignedChar> Function(
                  ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_get_request_contents_bin');
  late final _pactffi_sync_http_get_request_contents_bin =
      _pactffi_sync_http_get_request_contents_binPtr.asFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<SynchronousHttp>)>();

  /// Sets the request contents of the interaction as an array of bytes.
  ///
  /// * `interaction` - the interaction to set the request contents for
  /// * `contents` - pointer to contents to copy from
  /// * `len` - number of bytes to copy from the contents pointer
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The contents pointer must be valid for reads of `len` bytes, and it must be properly aligned
  /// and consecutive. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the request contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_sync_http_set_request_contents_bin(
    ffi.Pointer<SynchronousHttp> interaction,
    ffi.Pointer<ffi.UnsignedChar> contents,
    int len,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_sync_http_set_request_contents_bin(
      interaction,
      contents,
      len,
      content_type,
    );
  }

  late final _pactffi_sync_http_set_request_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<SynchronousHttp>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>)>>(
      'pactffi_sync_http_set_request_contents_bin');
  late final _pactffi_sync_http_set_request_contents_bin =
      _pactffi_sync_http_set_request_contents_binPtr.asFunction<
          void Function(ffi.Pointer<SynchronousHttp>,
              ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<ffi.Char>)>();

  /// Get the response of a `SynchronousHttp` interaction.
  ///
  /// # Safety
  ///
  /// The data pointed to by the pointer this function returns will be deleted when the interaction
  /// is deleted. Trying to use if after the interaction is deleted will result in undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the interaction is NULL, returns NULL.
  ffi.Pointer<HttpResponse> pactffi_sync_http_get_response(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_response(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_responsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<HttpResponse> Function(
              ffi.Pointer<SynchronousHttp>)>>('pactffi_sync_http_get_response');
  late final _pactffi_sync_http_get_response =
      _pactffi_sync_http_get_responsePtr.asFunction<
          ffi.Pointer<HttpResponse> Function(ffi.Pointer<SynchronousHttp>)>();

  /// Get the response contents of a `SynchronousHttp` interaction in string form.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// The returned string can outlive the interaction.
  ///
  /// # Error Handling
  ///
  /// If the interaction is NULL, returns NULL.
  ///
  /// If the body of the response is missing, then this function also returns NULL.
  /// This means there's no mechanism to differentiate with this function call alone between
  /// a NULL body and a missing body.
  ffi.Pointer<ffi.Char> pactffi_sync_http_get_response_contents(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_response_contents(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_response_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_get_response_contents');
  late final _pactffi_sync_http_get_response_contents =
      _pactffi_sync_http_get_response_contentsPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousHttp>)>();

  /// Sets the response contents of the interaction.
  ///
  /// * `interaction` - the interaction to set the response contents for
  /// * `contents` - pointer to contents to copy from. Must be a valid NULL-terminated UTF-8 string pointer.
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The response contents and content type must either be NULL pointers, or point to valid
  /// UTF-8 encoded NULL-terminated strings. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the response contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_sync_http_set_response_contents(
    ffi.Pointer<SynchronousHttp> interaction,
    ffi.Pointer<ffi.Char> contents,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_sync_http_set_response_contents(
      interaction,
      contents,
      content_type,
    );
  }

  late final _pactffi_sync_http_set_response_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SynchronousHttp>,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>(
      'pactffi_sync_http_set_response_contents');
  late final _pactffi_sync_http_set_response_contents =
      _pactffi_sync_http_set_response_contentsPtr.asFunction<
          void Function(ffi.Pointer<SynchronousHttp>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the length of the response contents of a `SynchronousHttp` interaction.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the interaction is NULL or the index is not valid, returns 0. If the body of the response
  /// is missing, then this function also returns 0.
  int pactffi_sync_http_get_response_contents_length(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_response_contents_length(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_response_contents_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_get_response_contents_length');
  late final _pactffi_sync_http_get_response_contents_length =
      _pactffi_sync_http_get_response_contents_lengthPtr
          .asFunction<int Function(ffi.Pointer<SynchronousHttp>)>();

  /// Get the response contents of a `SynchronousHttp` interaction as a pointer to an array of bytes.
  ///
  /// # Safety
  ///
  /// The number of bytes in the buffer will be returned by `pactffi_sync_http_get_response_contents_length`.
  /// It is safe to use the pointer while the interaction is not deleted or changed. Using the pointer
  /// after the interaction is mutated or deleted may lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the interaction is NULL, returns NULL. If the body of the response
  /// is missing, then this function also returns NULL.
  ffi.Pointer<ffi.UnsignedChar> pactffi_sync_http_get_response_contents_bin(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_response_contents_bin(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_response_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.UnsignedChar> Function(
                  ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_get_response_contents_bin');
  late final _pactffi_sync_http_get_response_contents_bin =
      _pactffi_sync_http_get_response_contents_binPtr.asFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<SynchronousHttp>)>();

  /// Sets the response contents of the `SynchronousHttp` interaction as an array of bytes.
  ///
  /// * `interaction` - the interaction to set the response contents for
  /// * `contents` - pointer to contents to copy from
  /// * `len` - number of bytes to copy
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The contents pointer must be valid for reads of `len` bytes, and it must be properly aligned
  /// and consecutive. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the response contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_sync_http_set_response_contents_bin(
    ffi.Pointer<SynchronousHttp> interaction,
    ffi.Pointer<ffi.UnsignedChar> contents,
    int len,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_sync_http_set_response_contents_bin(
      interaction,
      contents,
      len,
      content_type,
    );
  }

  late final _pactffi_sync_http_set_response_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<SynchronousHttp>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>)>>(
      'pactffi_sync_http_set_response_contents_bin');
  late final _pactffi_sync_http_set_response_contents_bin =
      _pactffi_sync_http_set_response_contents_binPtr.asFunction<
          void Function(ffi.Pointer<SynchronousHttp>,
              ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<ffi.Char>)>();

  /// Get a copy of the description.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// Since it is a copy, the returned string may safely outlive
  /// the `SynchronousHttp` interaction.
  ///
  /// # Errors
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if the Rust string contains embedded
  /// null ('\0') bytes.
  ffi.Pointer<ffi.Char> pactffi_sync_http_get_description(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_description(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_descriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_get_description');
  late final _pactffi_sync_http_get_description =
      _pactffi_sync_http_get_descriptionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousHttp>)>();

  /// Write the `description` field on the `SynchronousHttp`.
  ///
  /// # Safety
  ///
  /// `description` must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  ///
  /// This function will only reallocate if the new string
  /// does not fit in the existing buffer.
  ///
  /// # Error Handling
  ///
  /// Errors will be reported with a non-zero return value.
  int pactffi_sync_http_set_description(
    ffi.Pointer<SynchronousHttp> interaction,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_sync_http_set_description(
      interaction,
      description,
    );
  }

  late final _pactffi_sync_http_set_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SynchronousHttp>,
              ffi.Pointer<ffi.Char>)>>('pactffi_sync_http_set_description');
  late final _pactffi_sync_http_set_description =
      _pactffi_sync_http_set_descriptionPtr.asFunction<
          int Function(ffi.Pointer<SynchronousHttp>, ffi.Pointer<ffi.Char>)>();

  /// Get a copy of the provider state at the given index from this interaction.
  ///
  /// # Safety
  ///
  /// The returned structure must be deleted with `provider_state_delete`.
  ///
  /// Since it is a copy, the returned structure may safely outlive
  /// the `SynchronousHttp`.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a variant other than Success.
  ///
  /// This function may fail if the index requested is out of bounds,
  /// or if any of the Rust strings contain embedded null ('\0') bytes.
  ffi.Pointer<ProviderState> pactffi_sync_http_get_provider_state(
    ffi.Pointer<SynchronousHttp> interaction,
    int index,
  ) {
    return _pactffi_sync_http_get_provider_state(
      interaction,
      index,
    );
  }

  late final _pactffi_sync_http_get_provider_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ProviderState> Function(ffi.Pointer<SynchronousHttp>,
              ffi.UnsignedInt)>>('pactffi_sync_http_get_provider_state');
  late final _pactffi_sync_http_get_provider_state =
      _pactffi_sync_http_get_provider_statePtr.asFunction<
          ffi.Pointer<ProviderState> Function(
              ffi.Pointer<SynchronousHttp>, int)>();

  /// Get an iterator over provider states.
  ///
  /// # Safety
  ///
  /// The underlying data must not change during iteration.
  ///
  /// # Error Handling
  ///
  /// Returns NULL if an error occurs.
  ffi.Pointer<ProviderStateIterator> pactffi_sync_http_get_provider_state_iter(
    ffi.Pointer<SynchronousHttp> interaction,
  ) {
    return _pactffi_sync_http_get_provider_state_iter(
      interaction,
    );
  }

  late final _pactffi_sync_http_get_provider_state_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ProviderStateIterator> Function(
                  ffi.Pointer<SynchronousHttp>)>>(
      'pactffi_sync_http_get_provider_state_iter');
  late final _pactffi_sync_http_get_provider_state_iter =
      _pactffi_sync_http_get_provider_state_iterPtr.asFunction<
          ffi.Pointer<ProviderStateIterator> Function(
              ffi.Pointer<SynchronousHttp>)>();

  /// Casts this interaction to a `SynchronousHttp` interaction. Returns a NULL pointer if the
  /// interaction can not be casted to a `SynchronousHttp` interaction (for instance, it is a
  /// message interaction). The returned pointer must be freed with `pactffi_sync_http_delete`
  /// when no longer required.
  ///
  /// # Safety
  /// This function is safe as long as the interaction pointer is a valid pointer.
  ///
  /// # Errors
  /// On any error, this function will return a NULL pointer.
  ffi.Pointer<SynchronousHttp> pactffi_pact_interaction_as_synchronous_http(
    ffi.Pointer<PactInteraction> interaction,
  ) {
    return _pactffi_pact_interaction_as_synchronous_http(
      interaction,
    );
  }

  late final _pactffi_pact_interaction_as_synchronous_httpPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SynchronousHttp> Function(
                  ffi.Pointer<PactInteraction>)>>(
      'pactffi_pact_interaction_as_synchronous_http');
  late final _pactffi_pact_interaction_as_synchronous_http =
      _pactffi_pact_interaction_as_synchronous_httpPtr.asFunction<
          ffi.Pointer<SynchronousHttp> Function(
              ffi.Pointer<PactInteraction>)>();

  /// Casts this interaction to a `Message` interaction. Returns a NULL pointer if the
  /// interaction can not be casted to a `Message` interaction (for instance, it is a
  /// http interaction). The returned pointer must be freed with `pactffi_message_delete`
  /// when no longer required.
  ///
  /// Note that if the interaction is a V4 `AsynchronousMessage`, it will be converted to a V3
  /// `Message` before being returned.
  ///
  /// # Safety
  /// This function is safe as long as the interaction pointer is a valid pointer.
  ///
  /// # Errors
  /// On any error, this function will return a NULL pointer.
  ffi.Pointer<Message> pactffi_pact_interaction_as_message(
    ffi.Pointer<PactInteraction> interaction,
  ) {
    return _pactffi_pact_interaction_as_message(
      interaction,
    );
  }

  late final _pactffi_pact_interaction_as_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<Message> Function(ffi.Pointer<PactInteraction>)>>(
      'pactffi_pact_interaction_as_message');
  late final _pactffi_pact_interaction_as_message =
      _pactffi_pact_interaction_as_messagePtr.asFunction<
          ffi.Pointer<Message> Function(ffi.Pointer<PactInteraction>)>();

  /// Casts this interaction to a `AsynchronousMessage` interaction. Returns a NULL pointer if the
  /// interaction can not be casted to a `AsynchronousMessage` interaction (for instance, it is a
  /// http interaction). The returned pointer must be freed with `pactffi_async_message_delete`
  /// when no longer required.
  ///
  /// Note that if the interaction is a V3 `Message`, it will be converted to a V4
  /// `AsynchronousMessage` before being returned.
  ///
  /// # Safety
  /// This function is safe as long as the interaction pointer is a valid pointer.
  ///
  /// # Errors
  /// On any error, this function will return a NULL pointer.
  ffi.Pointer<AsynchronousMessage>
      pactffi_pact_interaction_as_asynchronous_message(
    ffi.Pointer<PactInteraction> interaction,
  ) {
    return _pactffi_pact_interaction_as_asynchronous_message(
      interaction,
    );
  }

  late final _pactffi_pact_interaction_as_asynchronous_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AsynchronousMessage> Function(
                  ffi.Pointer<PactInteraction>)>>(
      'pactffi_pact_interaction_as_asynchronous_message');
  late final _pactffi_pact_interaction_as_asynchronous_message =
      _pactffi_pact_interaction_as_asynchronous_messagePtr.asFunction<
          ffi.Pointer<AsynchronousMessage> Function(
              ffi.Pointer<PactInteraction>)>();

  /// Casts this interaction to a `SynchronousMessage` interaction. Returns a NULL pointer if the
  /// interaction can not be casted to a `SynchronousMessage` interaction (for instance, it is a
  /// http interaction). The returned pointer must be freed with `pactffi_sync_message_delete`
  /// when no longer required.
  ///
  /// # Safety
  /// This function is safe as long as the interaction pointer is a valid pointer.
  ///
  /// # Errors
  /// On any error, this function will return a NULL pointer.
  ffi.Pointer<SynchronousMessage>
      pactffi_pact_interaction_as_synchronous_message(
    ffi.Pointer<PactInteraction> interaction,
  ) {
    return _pactffi_pact_interaction_as_synchronous_message(
      interaction,
    );
  }

  late final _pactffi_pact_interaction_as_synchronous_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SynchronousMessage> Function(
                  ffi.Pointer<PactInteraction>)>>(
      'pactffi_pact_interaction_as_synchronous_message');
  late final _pactffi_pact_interaction_as_synchronous_message =
      _pactffi_pact_interaction_as_synchronous_messagePtr.asFunction<
          ffi.Pointer<SynchronousMessage> Function(
              ffi.Pointer<PactInteraction>)>();

  /// Free the iterator when you're done using it.
  void pactffi_pact_message_iter_delete(
    ffi.Pointer<PactMessageIterator> iter,
  ) {
    return _pactffi_pact_message_iter_delete(
      iter,
    );
  }

  late final _pactffi_pact_message_iter_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<PactMessageIterator>)>>(
      'pactffi_pact_message_iter_delete');
  late final _pactffi_pact_message_iter_delete =
      _pactffi_pact_message_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<PactMessageIterator>)>();

  /// Get the next message from the message pact. As the messages returned are owned by the
  /// iterator, they do not need to be deleted but will be cleaned up when the iterator is
  /// deleted.
  ///
  /// Will return a NULL pointer when the iterator has advanced past the end of the list.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// Deleting a message returned by the iterator can lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// This function will return a NULL pointer if passed a NULL pointer or if an error occurs.
  ffi.Pointer<Message> pactffi_pact_message_iter_next(
    ffi.Pointer<PactMessageIterator> iter,
  ) {
    return _pactffi_pact_message_iter_next(
      iter,
    );
  }

  late final _pactffi_pact_message_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<Message> Function(ffi.Pointer<PactMessageIterator>)>>(
      'pactffi_pact_message_iter_next');
  late final _pactffi_pact_message_iter_next =
      _pactffi_pact_message_iter_nextPtr.asFunction<
          ffi.Pointer<Message> Function(ffi.Pointer<PactMessageIterator>)>();

  /// Get the next asynchronous from the V4 pact. As the messages returned are
  /// owned by the iterator, they do not need to be deleted but will be
  /// cleaned up when the iterator is deleted.
  ///
  /// Will return a NULL pointer when the iterator has advanced past the end
  /// of the list.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// Deleting a message returned by the iterator can lead to undefined
  /// behaviour.
  ///
  /// # Error Handling
  ///
  /// This function will return a NULL pointer if passed a NULL pointer or if
  /// an error occurs.
  ffi.Pointer<AsynchronousMessage> pactffi_pact_async_message_iter_next(
    ffi.Pointer<PactAsyncMessageIterator> iter,
  ) {
    return _pactffi_pact_async_message_iter_next(
      iter,
    );
  }

  late final _pactffi_pact_async_message_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AsynchronousMessage> Function(
                  ffi.Pointer<PactAsyncMessageIterator>)>>(
      'pactffi_pact_async_message_iter_next');
  late final _pactffi_pact_async_message_iter_next =
      _pactffi_pact_async_message_iter_nextPtr.asFunction<
          ffi.Pointer<AsynchronousMessage> Function(
              ffi.Pointer<PactAsyncMessageIterator>)>();

  /// Free the iterator when you're done using it.
  void pactffi_pact_async_message_iter_delete(
    ffi.Pointer<PactAsyncMessageIterator> iter,
  ) {
    return _pactffi_pact_async_message_iter_delete(
      iter,
    );
  }

  late final _pactffi_pact_async_message_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<PactAsyncMessageIterator>)>>(
      'pactffi_pact_async_message_iter_delete');
  late final _pactffi_pact_async_message_iter_delete =
      _pactffi_pact_async_message_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<PactAsyncMessageIterator>)>();

  /// Get the next synchronous request/response message from the V4 pact. As the messages returned are owned by the
  /// iterator, they do not need to be deleted but will be cleaned up when the iterator is
  /// deleted.
  ///
  /// Will return a NULL pointer when the iterator has advanced past the end of the list.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// Deleting a message returned by the iterator can lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// This function will return a NULL pointer if passed a NULL pointer or if an error occurs.
  ffi.Pointer<SynchronousMessage> pactffi_pact_sync_message_iter_next(
    ffi.Pointer<PactSyncMessageIterator> iter,
  ) {
    return _pactffi_pact_sync_message_iter_next(
      iter,
    );
  }

  late final _pactffi_pact_sync_message_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SynchronousMessage> Function(
                  ffi.Pointer<PactSyncMessageIterator>)>>(
      'pactffi_pact_sync_message_iter_next');
  late final _pactffi_pact_sync_message_iter_next =
      _pactffi_pact_sync_message_iter_nextPtr.asFunction<
          ffi.Pointer<SynchronousMessage> Function(
              ffi.Pointer<PactSyncMessageIterator>)>();

  /// Free the iterator when you're done using it.
  void pactffi_pact_sync_message_iter_delete(
    ffi.Pointer<PactSyncMessageIterator> iter,
  ) {
    return _pactffi_pact_sync_message_iter_delete(
      iter,
    );
  }

  late final _pactffi_pact_sync_message_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<PactSyncMessageIterator>)>>(
      'pactffi_pact_sync_message_iter_delete');
  late final _pactffi_pact_sync_message_iter_delete =
      _pactffi_pact_sync_message_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<PactSyncMessageIterator>)>();

  /// Get the next synchronous HTTP request/response interaction from the V4 pact. As the
  /// interactions returned are owned by the iterator, they do not need to be deleted but
  /// will be cleaned up when the iterator is deleted.
  ///
  /// Will return a NULL pointer when the iterator has advanced past the end of the list.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// Deleting an interaction returned by the iterator can lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// This function will return a NULL pointer if passed a NULL pointer or if an error occurs.
  ffi.Pointer<SynchronousHttp> pactffi_pact_sync_http_iter_next(
    ffi.Pointer<PactSyncHttpIterator> iter,
  ) {
    return _pactffi_pact_sync_http_iter_next(
      iter,
    );
  }

  late final _pactffi_pact_sync_http_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SynchronousHttp> Function(
                  ffi.Pointer<PactSyncHttpIterator>)>>(
      'pactffi_pact_sync_http_iter_next');
  late final _pactffi_pact_sync_http_iter_next =
      _pactffi_pact_sync_http_iter_nextPtr.asFunction<
          ffi.Pointer<SynchronousHttp> Function(
              ffi.Pointer<PactSyncHttpIterator>)>();

  /// Free the iterator when you're done using it.
  void pactffi_pact_sync_http_iter_delete(
    ffi.Pointer<PactSyncHttpIterator> iter,
  ) {
    return _pactffi_pact_sync_http_iter_delete(
      iter,
    );
  }

  late final _pactffi_pact_sync_http_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<PactSyncHttpIterator>)>>(
      'pactffi_pact_sync_http_iter_delete');
  late final _pactffi_pact_sync_http_iter_delete =
      _pactffi_pact_sync_http_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<PactSyncHttpIterator>)>();

  /// Get the next interaction from the pact. As the interactions returned are owned by the
  /// iterator, they do not need to be deleted but will be cleaned up when the iterator is
  /// deleted.
  ///
  /// Will return a NULL pointer when the iterator has advanced past the end of the list.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// Deleting an interaction returned by the iterator can lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// This function will return a NULL pointer if passed a NULL pointer or if an error occurs.
  ffi.Pointer<PactInteraction> pactffi_pact_interaction_iter_next(
    ffi.Pointer<PactInteractionIterator> iter,
  ) {
    return _pactffi_pact_interaction_iter_next(
      iter,
    );
  }

  late final _pactffi_pact_interaction_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<PactInteraction> Function(
                  ffi.Pointer<PactInteractionIterator>)>>(
      'pactffi_pact_interaction_iter_next');
  late final _pactffi_pact_interaction_iter_next =
      _pactffi_pact_interaction_iter_nextPtr.asFunction<
          ffi.Pointer<PactInteraction> Function(
              ffi.Pointer<PactInteractionIterator>)>();

  /// Free the iterator when you're done using it.
  void pactffi_pact_interaction_iter_delete(
    ffi.Pointer<PactInteractionIterator> iter,
  ) {
    return _pactffi_pact_interaction_iter_delete(
      iter,
    );
  }

  late final _pactffi_pact_interaction_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<PactInteractionIterator>)>>(
      'pactffi_pact_interaction_iter_delete');
  late final _pactffi_pact_interaction_iter_delete =
      _pactffi_pact_interaction_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<PactInteractionIterator>)>();

  /// Get the JSON form of the matching rule.
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// # Safety
  ///
  /// This function will fail if it is passed a NULL pointer, or the iterator that owns the
  /// value of the matching rule has been deleted.
  ffi.Pointer<ffi.Char> pactffi_matching_rule_to_json(
    ffi.Pointer<MatchingRule> rule,
  ) {
    return _pactffi_matching_rule_to_json(
      rule,
    );
  }

  late final _pactffi_matching_rule_to_jsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>)>>('pactffi_matching_rule_to_json');
  late final _pactffi_matching_rule_to_json = _pactffi_matching_rule_to_jsonPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRule>)>();

  /// Free the iterator when you're done using it.
  void pactffi_matching_rules_iter_delete(
    ffi.Pointer<MatchingRuleCategoryIterator> iter,
  ) {
    return _pactffi_matching_rules_iter_delete(
      iter,
    );
  }

  late final _pactffi_matching_rules_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MatchingRuleCategoryIterator>)>>(
      'pactffi_matching_rules_iter_delete');
  late final _pactffi_matching_rules_iter_delete =
      _pactffi_matching_rules_iter_deletePtr.asFunction<
          void Function(ffi.Pointer<MatchingRuleCategoryIterator>)>();

  /// Get the next path and matching rule out of the iterator, if possible.
  ///
  /// The returned pointer must be deleted with `pactffi_matching_rules_iter_pair_delete`.
  ///
  /// # Safety
  ///
  /// The underlying data is owned by the `MatchingRuleKeyValuePair`, so is always safe to use.
  ///
  /// # Error Handling
  ///
  /// If no further data is present, returns NULL.
  ffi.Pointer<MatchingRuleKeyValuePair> pactffi_matching_rules_iter_next(
    ffi.Pointer<MatchingRuleCategoryIterator> iter,
  ) {
    return _pactffi_matching_rules_iter_next(
      iter,
    );
  }

  late final _pactffi_matching_rules_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MatchingRuleKeyValuePair> Function(
                  ffi.Pointer<MatchingRuleCategoryIterator>)>>(
      'pactffi_matching_rules_iter_next');
  late final _pactffi_matching_rules_iter_next =
      _pactffi_matching_rules_iter_nextPtr.asFunction<
          ffi.Pointer<MatchingRuleKeyValuePair> Function(
              ffi.Pointer<MatchingRuleCategoryIterator>)>();

  /// Free a pair of key and value returned from `message_metadata_iter_next`.
  void pactffi_matching_rules_iter_pair_delete(
    ffi.Pointer<MatchingRuleKeyValuePair> pair,
  ) {
    return _pactffi_matching_rules_iter_pair_delete(
      pair,
    );
  }

  late final _pactffi_matching_rules_iter_pair_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MatchingRuleKeyValuePair>)>>(
      'pactffi_matching_rules_iter_pair_delete');
  late final _pactffi_matching_rules_iter_pair_delete =
      _pactffi_matching_rules_iter_pair_deletePtr
          .asFunction<void Function(ffi.Pointer<MatchingRuleKeyValuePair>)>();

  /// Get a mutable pointer to a newly-created default message on the heap.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// Returns NULL on error.
  ffi.Pointer<Message> pactffi_message_new() {
    return _pactffi_message_new();
  }

  late final _pactffi_message_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<Message> Function()>>(
          'pactffi_message_new');
  late final _pactffi_message_new =
      _pactffi_message_newPtr.asFunction<ffi.Pointer<Message> Function()>();

  /// Constructs a `Message` from the JSON string
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the JSON string is invalid or not UTF-8 encoded, returns a NULL.
  ffi.Pointer<Message> pactffi_message_new_from_json(
    int index,
    ffi.Pointer<ffi.Char> json_str,
    PactSpecification spec_version,
  ) {
    return _pactffi_message_new_from_json(
      index,
      json_str,
      spec_version.value,
    );
  }

  late final _pactffi_message_new_from_jsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Message> Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('pactffi_message_new_from_json');
  late final _pactffi_message_new_from_json =
      _pactffi_message_new_from_jsonPtr.asFunction<
          ffi.Pointer<Message> Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Constructs a `Message` from a body with a given content-type.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the body or content type are invalid or not UTF-8 encoded, returns NULL.
  ffi.Pointer<Message> pactffi_message_new_from_body(
    ffi.Pointer<ffi.Char> body,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_message_new_from_body(
      body,
      content_type,
    );
  }

  late final _pactffi_message_new_from_bodyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Message> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_new_from_body');
  late final _pactffi_message_new_from_body =
      _pactffi_message_new_from_bodyPtr.asFunction<
          ffi.Pointer<Message> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Destroy the `Message` being pointed to.
  void pactffi_message_delete(
    ffi.Pointer<Message> message,
  ) {
    return _pactffi_message_delete(
      message,
    );
  }

  late final _pactffi_message_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Message>)>>(
          'pactffi_message_delete');
  late final _pactffi_message_delete = _pactffi_message_deletePtr
      .asFunction<void Function(ffi.Pointer<Message>)>();

  /// Get the contents of a `Message` in string form.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete` and can outlive the message.
  /// This function must only ever be called from a foreign language. Calling it from a Rust function
  /// that has a Tokio runtime in its call stack can result in a deadlock.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL. If the body of the message
  /// is missing, then this function also returns NULL. This means there's
  /// no mechanism to differentiate with this function call alone between
  /// a NULL message and a missing message body.
  ffi.Pointer<ffi.Char> pactffi_message_get_contents(
    ffi.Pointer<Message> message,
  ) {
    return _pactffi_message_get_contents(
      message,
    );
  }

  late final _pactffi_message_get_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Message>)>>('pactffi_message_get_contents');
  late final _pactffi_message_get_contents = _pactffi_message_get_contentsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Message>)>();

  /// Sets the contents of the message.
  ///
  /// # Safety
  ///
  /// The message contents and content type must either be NULL pointers, or point to valid
  /// UTF-8 encoded NULL-terminated strings. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_message_set_contents(
    ffi.Pointer<Message> message,
    ffi.Pointer<ffi.Char> contents,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_message_set_contents(
      message,
      contents,
      content_type,
    );
  }

  late final _pactffi_message_set_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Message>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_set_contents');
  late final _pactffi_message_set_contents =
      _pactffi_message_set_contentsPtr.asFunction<
          void Function(ffi.Pointer<Message>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the length of the contents of a `Message`.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns 0. If the body of the message
  /// is missing, then this function also returns 0.
  int pactffi_message_get_contents_length(
    ffi.Pointer<Message> message,
  ) {
    return _pactffi_message_get_contents_length(
      message,
    );
  }

  late final _pactffi_message_get_contents_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<Message>)>>(
          'pactffi_message_get_contents_length');
  late final _pactffi_message_get_contents_length =
      _pactffi_message_get_contents_lengthPtr
          .asFunction<int Function(ffi.Pointer<Message>)>();

  /// Get the contents of a `Message` as a pointer to an array of bytes.
  ///
  /// # Safety
  ///
  /// The number of bytes in the buffer will be returned by `pactffi_message_get_contents_length`.
  /// It is safe to use the pointer while the message is not deleted or changed. Using the pointer
  /// after the message is mutated or deleted may lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL. If the body of the message
  /// is missing, then this function also returns NULL.
  ffi.Pointer<ffi.UnsignedChar> pactffi_message_get_contents_bin(
    ffi.Pointer<Message> message,
  ) {
    return _pactffi_message_get_contents_bin(
      message,
    );
  }

  late final _pactffi_message_get_contents_binPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<Message>)>>('pactffi_message_get_contents_bin');
  late final _pactffi_message_get_contents_bin =
      _pactffi_message_get_contents_binPtr.asFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<Message>)>();

  /// Sets the contents of the message as an array of bytes.
  ///
  /// # Safety
  ///
  /// The contents pointer must be valid for reads of `len` bytes, and it must be properly aligned
  /// and consecutive. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_message_set_contents_bin(
    ffi.Pointer<Message> message,
    ffi.Pointer<ffi.UnsignedChar> contents,
    int len,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_message_set_contents_bin(
      message,
      contents,
      len,
      content_type,
    );
  }

  late final _pactffi_message_set_contents_binPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Message>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_set_contents_bin');
  late final _pactffi_message_set_contents_bin =
      _pactffi_message_set_contents_binPtr.asFunction<
          void Function(ffi.Pointer<Message>, ffi.Pointer<ffi.UnsignedChar>,
              int, ffi.Pointer<ffi.Char>)>();

  /// Get a copy of the description.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// Since it is a copy, the returned string may safely outlive
  /// the `Message`.
  ///
  /// # Errors
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if the Rust string contains embedded
  /// null ('\0') bytes.
  ffi.Pointer<ffi.Char> pactffi_message_get_description(
    ffi.Pointer<Message> message,
  ) {
    return _pactffi_message_get_description(
      message,
    );
  }

  late final _pactffi_message_get_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Message>)>>('pactffi_message_get_description');
  late final _pactffi_message_get_description =
      _pactffi_message_get_descriptionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Message>)>();

  /// Write the `description` field on the `Message`.
  ///
  /// # Safety
  ///
  /// `description` must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  ///
  /// This function will only reallocate if the new string
  /// does not fit in the existing buffer.
  ///
  /// # Error Handling
  ///
  /// Errors will be reported with a non-zero return value.
  int pactffi_message_set_description(
    ffi.Pointer<Message> message,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_message_set_description(
      message,
      description,
    );
  }

  late final _pactffi_message_set_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<Message>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_set_description');
  late final _pactffi_message_set_description =
      _pactffi_message_set_descriptionPtr.asFunction<
          int Function(ffi.Pointer<Message>, ffi.Pointer<ffi.Char>)>();

  /// Get a copy of the provider state at the given index from this message.
  ///
  /// # Safety
  ///
  /// The returned structure must be deleted with `provider_state_delete`.
  ///
  /// Since it is a copy, the returned structure may safely outlive
  /// the `Message`.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a variant other than Success.
  ///
  /// This function may fail if the index requested is out of bounds,
  /// or if any of the Rust strings contain embedded null ('\0') bytes.
  ffi.Pointer<ProviderState> pactffi_message_get_provider_state(
    ffi.Pointer<Message> message,
    int index,
  ) {
    return _pactffi_message_get_provider_state(
      message,
      index,
    );
  }

  late final _pactffi_message_get_provider_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ProviderState> Function(ffi.Pointer<Message>,
              ffi.UnsignedInt)>>('pactffi_message_get_provider_state');
  late final _pactffi_message_get_provider_state =
      _pactffi_message_get_provider_statePtr.asFunction<
          ffi.Pointer<ProviderState> Function(ffi.Pointer<Message>, int)>();

  /// Get an iterator over provider states.
  ///
  /// # Safety
  ///
  /// The underlying data must not change during iteration.
  ///
  /// # Error Handling
  ///
  /// Returns NULL if an error occurs.
  ffi.Pointer<ProviderStateIterator> pactffi_message_get_provider_state_iter(
    ffi.Pointer<Message> message,
  ) {
    return _pactffi_message_get_provider_state_iter(
      message,
    );
  }

  late final _pactffi_message_get_provider_state_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ProviderStateIterator> Function(
                  ffi.Pointer<Message>)>>(
      'pactffi_message_get_provider_state_iter');
  late final _pactffi_message_get_provider_state_iter =
      _pactffi_message_get_provider_state_iterPtr.asFunction<
          ffi.Pointer<ProviderStateIterator> Function(ffi.Pointer<Message>)>();

  /// Get the next value from the iterator.
  ///
  /// # Safety
  ///
  /// The underlying data must not change during iteration.
  ///
  /// If a previous call panicked, then the internal mutex will have been poisoned and this
  /// function will return NULL.
  ///
  /// # Error Handling
  ///
  /// Returns NULL if an error occurs.
  ffi.Pointer<ProviderState> pactffi_provider_state_iter_next(
    ffi.Pointer<ProviderStateIterator> iter,
  ) {
    return _pactffi_provider_state_iter_next(
      iter,
    );
  }

  late final _pactffi_provider_state_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ProviderState> Function(
                  ffi.Pointer<ProviderStateIterator>)>>(
      'pactffi_provider_state_iter_next');
  late final _pactffi_provider_state_iter_next =
      _pactffi_provider_state_iter_nextPtr.asFunction<
          ffi.Pointer<ProviderState> Function(
              ffi.Pointer<ProviderStateIterator>)>();

  /// Delete the iterator.
  void pactffi_provider_state_iter_delete(
    ffi.Pointer<ProviderStateIterator> iter,
  ) {
    return _pactffi_provider_state_iter_delete(
      iter,
    );
  }

  late final _pactffi_provider_state_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ProviderStateIterator>)>>(
      'pactffi_provider_state_iter_delete');
  late final _pactffi_provider_state_iter_delete =
      _pactffi_provider_state_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<ProviderStateIterator>)>();

  /// Get a copy of the metadata value indexed by `key`.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// Since it is a copy, the returned string may safely outlive
  /// the `Message`.
  ///
  /// The returned pointer will be NULL if the metadata does not contain
  /// the given key, or if an error occurred.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if the provided `key` string contains
  /// invalid UTF-8, or if the Rust string contains embedded null ('\0')
  /// bytes.
  ffi.Pointer<ffi.Char> pactffi_message_find_metadata(
    ffi.Pointer<Message> message,
    ffi.Pointer<ffi.Char> key,
  ) {
    return _pactffi_message_find_metadata(
      message,
      key,
    );
  }

  late final _pactffi_message_find_metadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<Message>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_find_metadata');
  late final _pactffi_message_find_metadata =
      _pactffi_message_find_metadataPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Message>, ffi.Pointer<ffi.Char>)>();

  /// Insert the (`key`, `value`) pair into this Message's
  /// `metadata` HashMap.
  ///
  /// # Safety
  ///
  /// This function returns an enum indicating the result;
  /// see the comments on HashMapInsertStatus for details.
  ///
  /// # Error Handling
  ///
  /// This function may fail if the provided `key` or `value` strings
  /// contain invalid UTF-8.
  int pactffi_message_insert_metadata(
    ffi.Pointer<Message> message,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_message_insert_metadata(
      message,
      key,
      value,
    );
  }

  late final _pactffi_message_insert_metadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<Message>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_insert_metadata');
  late final _pactffi_message_insert_metadata =
      _pactffi_message_insert_metadataPtr.asFunction<
          int Function(ffi.Pointer<Message>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the next key and value out of the iterator, if possible.
  ///
  /// The returned pointer must be deleted with `pactffi_message_metadata_pair_delete`.
  ///
  /// # Safety
  ///
  /// The underlying data must not change during iteration.
  /// This function must only ever be called from a foreign language. Calling it from a Rust function
  /// that has a Tokio runtime in its call stack can result in a deadlock.
  ///
  /// # Error Handling
  ///
  /// If no further data is present, returns NULL.
  ffi.Pointer<MessageMetadataPair> pactffi_message_metadata_iter_next(
    ffi.Pointer<MessageMetadataIterator> iter,
  ) {
    return _pactffi_message_metadata_iter_next(
      iter,
    );
  }

  late final _pactffi_message_metadata_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessageMetadataPair> Function(
                  ffi.Pointer<MessageMetadataIterator>)>>(
      'pactffi_message_metadata_iter_next');
  late final _pactffi_message_metadata_iter_next =
      _pactffi_message_metadata_iter_nextPtr.asFunction<
          ffi.Pointer<MessageMetadataPair> Function(
              ffi.Pointer<MessageMetadataIterator>)>();

  /// Get an iterator over the metadata of a message.
  ///
  /// # Safety
  ///
  /// This iterator carries a pointer to the message, and must
  /// not outlive the message.
  ///
  /// The message metadata also must not be modified during iteration. If it is,
  /// the old iterator must be deleted and a new iterator created.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain
  /// embedded null ('\0') bytes.
  ffi.Pointer<MessageMetadataIterator> pactffi_message_get_metadata_iter(
    ffi.Pointer<Message> message,
  ) {
    return _pactffi_message_get_metadata_iter(
      message,
    );
  }

  late final _pactffi_message_get_metadata_iterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<MessageMetadataIterator> Function(
              ffi.Pointer<Message>)>>('pactffi_message_get_metadata_iter');
  late final _pactffi_message_get_metadata_iter =
      _pactffi_message_get_metadata_iterPtr.asFunction<
          ffi.Pointer<MessageMetadataIterator> Function(
              ffi.Pointer<Message>)>();

  /// Free the metadata iterator when you're done using it.
  void pactffi_message_metadata_iter_delete(
    ffi.Pointer<MessageMetadataIterator> iter,
  ) {
    return _pactffi_message_metadata_iter_delete(
      iter,
    );
  }

  late final _pactffi_message_metadata_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MessageMetadataIterator>)>>(
      'pactffi_message_metadata_iter_delete');
  late final _pactffi_message_metadata_iter_delete =
      _pactffi_message_metadata_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<MessageMetadataIterator>)>();

  /// Free a pair of key and value returned from `message_metadata_iter_next`.
  void pactffi_message_metadata_pair_delete(
    ffi.Pointer<MessageMetadataPair> pair,
  ) {
    return _pactffi_message_metadata_pair_delete(
      pair,
    );
  }

  late final _pactffi_message_metadata_pair_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<MessageMetadataPair>)>>(
      'pactffi_message_metadata_pair_delete');
  late final _pactffi_message_metadata_pair_delete =
      _pactffi_message_metadata_pair_deletePtr
          .asFunction<void Function(ffi.Pointer<MessageMetadataPair>)>();

  /// Construct a new `MessagePact` from the JSON string.
  /// The provided file name is used when generating error messages.
  ///
  /// # Safety
  ///
  /// The `file_name` and `json_str` parameters must both be valid UTF-8
  /// encoded strings.
  ///
  /// # Error Handling
  ///
  /// On error, this function will return a null pointer.
  ffi.Pointer<MessagePact> pactffi_message_pact_new_from_json(
    ffi.Pointer<ffi.Char> file_name,
    ffi.Pointer<ffi.Char> json_str,
  ) {
    return _pactffi_message_pact_new_from_json(
      file_name,
      json_str,
    );
  }

  late final _pactffi_message_pact_new_from_jsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<MessagePact> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_pact_new_from_json');
  late final _pactffi_message_pact_new_from_json =
      _pactffi_message_pact_new_from_jsonPtr.asFunction<
          ffi.Pointer<MessagePact> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Delete the `MessagePact` being pointed to.
  void pactffi_message_pact_delete(
    ffi.Pointer<MessagePact> message_pact,
  ) {
    return _pactffi_message_pact_delete(
      message_pact,
    );
  }

  late final _pactffi_message_pact_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MessagePact>)>>(
          'pactffi_message_pact_delete');
  late final _pactffi_message_pact_delete = _pactffi_message_pact_deletePtr
      .asFunction<void Function(ffi.Pointer<MessagePact>)>();

  /// Get a pointer to the Consumer struct inside the MessagePact.
  /// This is a mutable borrow: The caller may mutate the Consumer
  /// through this pointer.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// This function will only fail if it is passed a NULL pointer.
  /// In the case of error, a NULL pointer will be returned.
  ffi.Pointer<Consumer> pactffi_message_pact_get_consumer(
    ffi.Pointer<MessagePact> message_pact,
  ) {
    return _pactffi_message_pact_get_consumer(
      message_pact,
    );
  }

  late final _pactffi_message_pact_get_consumerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Consumer> Function(
              ffi.Pointer<MessagePact>)>>('pactffi_message_pact_get_consumer');
  late final _pactffi_message_pact_get_consumer =
      _pactffi_message_pact_get_consumerPtr.asFunction<
          ffi.Pointer<Consumer> Function(ffi.Pointer<MessagePact>)>();

  /// Get a pointer to the Provider struct inside the MessagePact.
  /// This is a mutable borrow: The caller may mutate the Provider
  /// through this pointer.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// This function will only fail if it is passed a NULL pointer.
  /// In the case of error, a NULL pointer will be returned.
  ffi.Pointer<Provider> pactffi_message_pact_get_provider(
    ffi.Pointer<MessagePact> message_pact,
  ) {
    return _pactffi_message_pact_get_provider(
      message_pact,
    );
  }

  late final _pactffi_message_pact_get_providerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Provider> Function(
              ffi.Pointer<MessagePact>)>>('pactffi_message_pact_get_provider');
  late final _pactffi_message_pact_get_provider =
      _pactffi_message_pact_get_providerPtr.asFunction<
          ffi.Pointer<Provider> Function(ffi.Pointer<MessagePact>)>();

  /// Get an iterator over the messages of a message pact.
  ///
  /// # Safety
  ///
  /// This iterator carries a pointer to the message pact, and must
  /// not outlive the message pact.
  ///
  /// The message pact messages also must not be modified during iteration.
  /// If they are, the old iterator must be deleted and a new iterator created.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain embedded
  /// null ('\0') bytes.
  ffi.Pointer<MessagePactMessageIterator> pactffi_message_pact_get_message_iter(
    ffi.Pointer<MessagePact> message_pact,
  ) {
    return _pactffi_message_pact_get_message_iter(
      message_pact,
    );
  }

  late final _pactffi_message_pact_get_message_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessagePactMessageIterator> Function(
                  ffi.Pointer<MessagePact>)>>(
      'pactffi_message_pact_get_message_iter');
  late final _pactffi_message_pact_get_message_iter =
      _pactffi_message_pact_get_message_iterPtr.asFunction<
          ffi.Pointer<MessagePactMessageIterator> Function(
              ffi.Pointer<MessagePact>)>();

  /// Get the next message from the message pact.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// This function will return a NULL pointer if passed a NULL pointer or if an error occurs.
  ffi.Pointer<Message> pactffi_message_pact_message_iter_next(
    ffi.Pointer<MessagePactMessageIterator> iter,
  ) {
    return _pactffi_message_pact_message_iter_next(
      iter,
    );
  }

  late final _pactffi_message_pact_message_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<Message> Function(
                  ffi.Pointer<MessagePactMessageIterator>)>>(
      'pactffi_message_pact_message_iter_next');
  late final _pactffi_message_pact_message_iter_next =
      _pactffi_message_pact_message_iter_nextPtr.asFunction<
          ffi.Pointer<Message> Function(
              ffi.Pointer<MessagePactMessageIterator>)>();

  /// Delete the iterator.
  void pactffi_message_pact_message_iter_delete(
    ffi.Pointer<MessagePactMessageIterator> iter,
  ) {
    return _pactffi_message_pact_message_iter_delete(
      iter,
    );
  }

  late final _pactffi_message_pact_message_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MessagePactMessageIterator>)>>(
      'pactffi_message_pact_message_iter_delete');
  late final _pactffi_message_pact_message_iter_delete =
      _pactffi_message_pact_message_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<MessagePactMessageIterator>)>();

  /// Get a copy of the metadata value indexed by `key1` and `key2`.
  ///
  /// # Safety
  ///
  /// Since it is a copy, the returned string may safely outlive
  /// the `Message`.
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// The returned pointer will be NULL if the metadata does not contain
  /// the given key, or if an error occurred.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if the provided `key1` or `key2` strings contains
  /// invalid UTF-8, or if the Rust string contains embedded null ('\0')
  /// bytes.
  ffi.Pointer<ffi.Char> pactffi_message_pact_find_metadata(
    ffi.Pointer<MessagePact> message_pact,
    ffi.Pointer<ffi.Char> key1,
    ffi.Pointer<ffi.Char> key2,
  ) {
    return _pactffi_message_pact_find_metadata(
      message_pact,
      key1,
      key2,
    );
  }

  late final _pactffi_message_pact_find_metadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MessagePact>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_pact_find_metadata');
  late final _pactffi_message_pact_find_metadata =
      _pactffi_message_pact_find_metadataPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MessagePact>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Get an iterator over the metadata of a message pact.
  ///
  /// # Safety
  ///
  /// This iterator carries a pointer to the message pact, and must
  /// not outlive the message pact.
  ///
  /// The message pact metadata also must not be modified during iteration. If it is,
  /// the old iterator must be deleted and a new iterator created.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain
  /// embedded null ('\0') bytes.
  ffi.Pointer<MessagePactMetadataIterator>
      pactffi_message_pact_get_metadata_iter(
    ffi.Pointer<MessagePact> message_pact,
  ) {
    return _pactffi_message_pact_get_metadata_iter(
      message_pact,
    );
  }

  late final _pactffi_message_pact_get_metadata_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessagePactMetadataIterator> Function(
                  ffi.Pointer<MessagePact>)>>(
      'pactffi_message_pact_get_metadata_iter');
  late final _pactffi_message_pact_get_metadata_iter =
      _pactffi_message_pact_get_metadata_iterPtr.asFunction<
          ffi.Pointer<MessagePactMetadataIterator> Function(
              ffi.Pointer<MessagePact>)>();

  /// Get the next triple out of the iterator, if possible
  ///
  /// # Safety
  ///
  /// This operation is invalid if the underlying data has been changed during iteration.
  ///
  /// # Error Handling
  ///
  /// Returns null if no next element is present.
  ffi.Pointer<MessagePactMetadataTriple>
      pactffi_message_pact_metadata_iter_next(
    ffi.Pointer<MessagePactMetadataIterator> iter,
  ) {
    return _pactffi_message_pact_metadata_iter_next(
      iter,
    );
  }

  late final _pactffi_message_pact_metadata_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessagePactMetadataTriple> Function(
                  ffi.Pointer<MessagePactMetadataIterator>)>>(
      'pactffi_message_pact_metadata_iter_next');
  late final _pactffi_message_pact_metadata_iter_next =
      _pactffi_message_pact_metadata_iter_nextPtr.asFunction<
          ffi.Pointer<MessagePactMetadataTriple> Function(
              ffi.Pointer<MessagePactMetadataIterator>)>();

  /// Free the metadata iterator when you're done using it.
  void pactffi_message_pact_metadata_iter_delete(
    ffi.Pointer<MessagePactMetadataIterator> iter,
  ) {
    return _pactffi_message_pact_metadata_iter_delete(
      iter,
    );
  }

  late final _pactffi_message_pact_metadata_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MessagePactMetadataIterator>)>>(
      'pactffi_message_pact_metadata_iter_delete');
  late final _pactffi_message_pact_metadata_iter_delete =
      _pactffi_message_pact_metadata_iter_deletePtr.asFunction<
          void Function(ffi.Pointer<MessagePactMetadataIterator>)>();

  /// Free a triple returned from `pactffi_message_pact_metadata_iter_next`.
  void pactffi_message_pact_metadata_triple_delete(
    ffi.Pointer<MessagePactMetadataTriple> triple,
  ) {
    return _pactffi_message_pact_metadata_triple_delete(
      triple,
    );
  }

  late final _pactffi_message_pact_metadata_triple_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<MessagePactMetadataTriple>)>>(
      'pactffi_message_pact_metadata_triple_delete');
  late final _pactffi_message_pact_metadata_triple_delete =
      _pactffi_message_pact_metadata_triple_deletePtr
          .asFunction<void Function(ffi.Pointer<MessagePactMetadataTriple>)>();

  /// Get a copy of this provider's name.
  ///
  /// The copy must be deleted with `pactffi_string_delete`.
  ///
  /// # Usage
  ///
  /// ```c
  /// // Assuming `file_name` and `json_str` are already defined.
  ///
  /// MessagePact *message_pact = pactffi_message_pact_new_from_json(file_name, json_str);
  /// if (message_pact == NULLPTR) {
  /// // handle error.
  /// }
  ///
  /// Provider *provider = pactffi_message_pact_get_provider(message_pact);
  /// if (provider == NULLPTR) {
  /// // handle error.
  /// }
  ///
  /// char *name = pactffi_provider_get_name(provider);
  /// if (name == NULL) {
  /// // handle error.
  /// }
  ///
  /// printf("%s\n", name);
  ///
  /// pactffi_string_delete(name);
  /// ```
  ///
  /// # Errors
  ///
  /// This function will fail if it is passed a NULL pointer,
  /// or the Rust string contains an embedded NULL byte.
  /// In the case of error, a NULL pointer will be returned.
  ffi.Pointer<ffi.Char> pactffi_provider_get_name(
    ffi.Pointer<Provider> provider,
  ) {
    return _pactffi_provider_get_name(
      provider,
    );
  }

  late final _pactffi_provider_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Provider>)>>('pactffi_provider_get_name');
  late final _pactffi_provider_get_name = _pactffi_provider_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<Provider>)>();

  /// Get the provider from a Pact. This returns a copy of the provider model, and needs to
  /// be cleaned up with `pactffi_pact_provider_delete` when no longer required.
  ///
  /// # Errors
  ///
  /// This function will fail if it is passed a NULL pointer.
  /// In the case of error, a NULL pointer will be returned.
  ffi.Pointer<Provider> pactffi_pact_get_provider(
    ffi.Pointer<Pact> pact,
  ) {
    return _pactffi_pact_get_provider(
      pact,
    );
  }

  late final _pactffi_pact_get_providerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<Provider> Function(ffi.Pointer<Pact>)>>(
      'pactffi_pact_get_provider');
  late final _pactffi_pact_get_provider = _pactffi_pact_get_providerPtr
      .asFunction<ffi.Pointer<Provider> Function(ffi.Pointer<Pact>)>();

  /// Frees the memory used by the Pact provider
  void pactffi_pact_provider_delete(
    ffi.Pointer<Provider> provider,
  ) {
    return _pactffi_pact_provider_delete(
      provider,
    );
  }

  late final _pactffi_pact_provider_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Provider>)>>(
          'pactffi_pact_provider_delete');
  late final _pactffi_pact_provider_delete = _pactffi_pact_provider_deletePtr
      .asFunction<void Function(ffi.Pointer<Provider>)>();

  /// Get the name of the provider state as a string, which needs to be deleted with `pactffi_string_delete`.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the provider_state param is NULL, this returns NULL.
  ffi.Pointer<ffi.Char> pactffi_provider_state_get_name(
    ffi.Pointer<ProviderState> provider_state,
  ) {
    return _pactffi_provider_state_get_name(
      provider_state,
    );
  }

  late final _pactffi_provider_state_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ProviderState>)>>('pactffi_provider_state_get_name');
  late final _pactffi_provider_state_get_name =
      _pactffi_provider_state_get_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ProviderState>)>();

  /// Get an iterator over the params of a provider state.
  ///
  /// # Safety
  ///
  /// This iterator carries a pointer to the provider state, and must
  /// not outlive the provider state.
  ///
  /// The provider state params also must not be modified during iteration. If it is,
  /// the old iterator must be deleted and a new iterator created.
  ///
  /// # Errors
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain
  /// embedded null ('\0') bytes.
  ffi.Pointer<ProviderStateParamIterator> pactffi_provider_state_get_param_iter(
    ffi.Pointer<ProviderState> provider_state,
  ) {
    return _pactffi_provider_state_get_param_iter(
      provider_state,
    );
  }

  late final _pactffi_provider_state_get_param_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ProviderStateParamIterator> Function(
                  ffi.Pointer<ProviderState>)>>(
      'pactffi_provider_state_get_param_iter');
  late final _pactffi_provider_state_get_param_iter =
      _pactffi_provider_state_get_param_iterPtr.asFunction<
          ffi.Pointer<ProviderStateParamIterator> Function(
              ffi.Pointer<ProviderState>)>();

  /// Get the next key and value out of the iterator, if possible
  ///
  /// Returns a pointer to a heap allocated array of 2 elements, the pointer to the
  /// key string on the heap, and the pointer to the value string on the heap.
  ///
  /// # Safety
  ///
  /// The underlying data must not be modified during iteration.
  ///
  /// The user needs to free both the contained strings and the array.
  ///
  /// # Error Handling
  ///
  /// Returns NULL if there's no further elements or the iterator is NULL.
  ffi.Pointer<ProviderStateParamPair> pactffi_provider_state_param_iter_next(
    ffi.Pointer<ProviderStateParamIterator> iter,
  ) {
    return _pactffi_provider_state_param_iter_next(
      iter,
    );
  }

  late final _pactffi_provider_state_param_iter_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ProviderStateParamPair> Function(
                  ffi.Pointer<ProviderStateParamIterator>)>>(
      'pactffi_provider_state_param_iter_next');
  late final _pactffi_provider_state_param_iter_next =
      _pactffi_provider_state_param_iter_nextPtr.asFunction<
          ffi.Pointer<ProviderStateParamPair> Function(
              ffi.Pointer<ProviderStateParamIterator>)>();

  /// Free the provider state when you're done using it.
  void pactffi_provider_state_delete(
    ffi.Pointer<ProviderState> provider_state,
  ) {
    return _pactffi_provider_state_delete(
      provider_state,
    );
  }

  late final _pactffi_provider_state_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ProviderState>)>>(
      'pactffi_provider_state_delete');
  late final _pactffi_provider_state_delete = _pactffi_provider_state_deletePtr
      .asFunction<void Function(ffi.Pointer<ProviderState>)>();

  /// Free the provider state param iterator when you're done using it.
  void pactffi_provider_state_param_iter_delete(
    ffi.Pointer<ProviderStateParamIterator> iter,
  ) {
    return _pactffi_provider_state_param_iter_delete(
      iter,
    );
  }

  late final _pactffi_provider_state_param_iter_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ProviderStateParamIterator>)>>(
      'pactffi_provider_state_param_iter_delete');
  late final _pactffi_provider_state_param_iter_delete =
      _pactffi_provider_state_param_iter_deletePtr
          .asFunction<void Function(ffi.Pointer<ProviderStateParamIterator>)>();

  /// Free a pair of key and value returned from `pactffi_provider_state_param_iter_next`.
  void pactffi_provider_state_param_pair_delete(
    ffi.Pointer<ProviderStateParamPair> pair,
  ) {
    return _pactffi_provider_state_param_pair_delete(
      pair,
    );
  }

  late final _pactffi_provider_state_param_pair_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ProviderStateParamPair>)>>(
      'pactffi_provider_state_param_pair_delete');
  late final _pactffi_provider_state_param_pair_delete =
      _pactffi_provider_state_param_pair_deletePtr
          .asFunction<void Function(ffi.Pointer<ProviderStateParamPair>)>();

  /// Get a mutable pointer to a newly-created default message on the heap.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// Returns NULL on error.
  ffi.Pointer<SynchronousMessage> pactffi_sync_message_new() {
    return _pactffi_sync_message_new();
  }

  late final _pactffi_sync_message_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SynchronousMessage> Function()>>(
          'pactffi_sync_message_new');
  late final _pactffi_sync_message_new = _pactffi_sync_message_newPtr
      .asFunction<ffi.Pointer<SynchronousMessage> Function()>();

  /// Destroy the `Message` being pointed to.
  void pactffi_sync_message_delete(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_delete(
      message,
    );
  }

  late final _pactffi_sync_message_deletePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_delete');
  late final _pactffi_sync_message_delete = _pactffi_sync_message_deletePtr
      .asFunction<void Function(ffi.Pointer<SynchronousMessage>)>();

  /// Get the request contents of a `SynchronousMessage` in string form.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// The returned string can outlive the message.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL. If the body of the request message
  /// is missing, then this function also returns NULL. This means there's
  /// no mechanism to differentiate with this function call alone between
  /// a NULL message and a missing message body.
  ffi.Pointer<ffi.Char> pactffi_sync_message_get_request_contents_str(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_get_request_contents_str(
      message,
    );
  }

  late final _pactffi_sync_message_get_request_contents_strPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_get_request_contents_str');
  late final _pactffi_sync_message_get_request_contents_str =
      _pactffi_sync_message_get_request_contents_strPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousMessage>)>();

  /// Sets the request contents of the message.
  ///
  /// * `message` - the message to set the request contents for
  /// * `contents` - pointer to contents to copy from. Must be a valid NULL-terminated UTF-8 string pointer.
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The message contents and content type must either be NULL pointers, or point to valid
  /// UTF-8 encoded NULL-terminated strings. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_sync_message_set_request_contents_str(
    ffi.Pointer<SynchronousMessage> message,
    ffi.Pointer<ffi.Char> contents,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_sync_message_set_request_contents_str(
      message,
      contents,
      content_type,
    );
  }

  late final _pactffi_sync_message_set_request_contents_strPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SynchronousMessage>,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>(
      'pactffi_sync_message_set_request_contents_str');
  late final _pactffi_sync_message_set_request_contents_str =
      _pactffi_sync_message_set_request_contents_strPtr.asFunction<
          void Function(ffi.Pointer<SynchronousMessage>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the length of the request contents of a `SynchronousMessage`.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns 0. If the body of the request
  /// is missing, then this function also returns 0.
  int pactffi_sync_message_get_request_contents_length(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_get_request_contents_length(
      message,
    );
  }

  late final _pactffi_sync_message_get_request_contents_lengthPtr = _lookup<
          ffi
          .NativeFunction<ffi.Size Function(ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_get_request_contents_length');
  late final _pactffi_sync_message_get_request_contents_length =
      _pactffi_sync_message_get_request_contents_lengthPtr
          .asFunction<int Function(ffi.Pointer<SynchronousMessage>)>();

  /// Get the request contents of a `SynchronousMessage` as a pointer to an array of bytes.
  ///
  /// # Safety
  ///
  /// The number of bytes in the buffer will be returned by `pactffi_sync_message_get_request_contents_length`.
  /// It is safe to use the pointer while the message is not deleted or changed. Using the pointer
  /// after the message is mutated or deleted may lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL. If the body of the message
  /// is missing, then this function also returns NULL.
  ffi.Pointer<ffi.UnsignedChar> pactffi_sync_message_get_request_contents_bin(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_get_request_contents_bin(
      message,
    );
  }

  late final _pactffi_sync_message_get_request_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.UnsignedChar> Function(
                  ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_get_request_contents_bin');
  late final _pactffi_sync_message_get_request_contents_bin =
      _pactffi_sync_message_get_request_contents_binPtr.asFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<SynchronousMessage>)>();

  /// Sets the request contents of the message as an array of bytes.
  ///
  /// * `message` - the message to set the request contents for
  /// * `contents` - pointer to contents to copy from
  /// * `len` - number of bytes to copy from the contents pointer
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The contents pointer must be valid for reads of `len` bytes, and it must be properly aligned
  /// and consecutive. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_sync_message_set_request_contents_bin(
    ffi.Pointer<SynchronousMessage> message,
    ffi.Pointer<ffi.UnsignedChar> contents,
    int len,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_sync_message_set_request_contents_bin(
      message,
      contents,
      len,
      content_type,
    );
  }

  late final _pactffi_sync_message_set_request_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<SynchronousMessage>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>)>>(
      'pactffi_sync_message_set_request_contents_bin');
  late final _pactffi_sync_message_set_request_contents_bin =
      _pactffi_sync_message_set_request_contents_binPtr.asFunction<
          void Function(ffi.Pointer<SynchronousMessage>,
              ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<ffi.Char>)>();

  /// Get the request contents of an `SynchronousMessage` as a `MessageContents` pointer.
  ///
  /// # Safety
  ///
  /// The data pointed to by the pointer this function returns will be deleted when the message
  /// is deleted. Trying to use if after the message is deleted will result in undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL.
  ffi.Pointer<MessageContents> pactffi_sync_message_get_request_contents(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_get_request_contents(
      message,
    );
  }

  late final _pactffi_sync_message_get_request_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessageContents> Function(
                  ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_get_request_contents');
  late final _pactffi_sync_message_get_request_contents =
      _pactffi_sync_message_get_request_contentsPtr.asFunction<
          ffi.Pointer<MessageContents> Function(
              ffi.Pointer<SynchronousMessage>)>();

  /// Generate the request contents of a `SynchronousMessage` as a
  /// `MessageContents` pointer.
  ///
  /// This function differs from [`pactffi_sync_message_get_request_contents`]
  /// in that it will process the message contents for any generators or
  /// matchers that are present in the message in order to generate the actual
  /// message contents as would be received by the consumer.
  ///
  /// # Safety
  ///
  /// The data pointed to by the pointer must be deleted with
  /// [`pactffi_message_contents_delete`][crate::models::contents::pactffi_message_contents_delete]
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL.
  ffi.Pointer<MessageContents> pactffi_sync_message_generate_request_contents(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_generate_request_contents(
      message,
    );
  }

  late final _pactffi_sync_message_generate_request_contentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<MessageContents> Function(
                  ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_generate_request_contents');
  late final _pactffi_sync_message_generate_request_contents =
      _pactffi_sync_message_generate_request_contentsPtr.asFunction<
          ffi.Pointer<MessageContents> Function(
              ffi.Pointer<SynchronousMessage>)>();

  /// Get the number of response messages in the `SynchronousMessage`.
  ///
  /// # Safety
  ///
  /// The message pointer must point to a valid SynchronousMessage.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns 0.
  int pactffi_sync_message_get_number_responses(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_get_number_responses(
      message,
    );
  }

  late final _pactffi_sync_message_get_number_responsesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Size Function(ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_get_number_responses');
  late final _pactffi_sync_message_get_number_responses =
      _pactffi_sync_message_get_number_responsesPtr
          .asFunction<int Function(ffi.Pointer<SynchronousMessage>)>();

  /// Get the response contents of a `SynchronousMessage` in string form.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// The returned string can outlive the message.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL or the index is not valid, returns NULL.
  ///
  /// If the body of the response message is missing, then this function also returns NULL.
  /// This means there's no mechanism to differentiate with this function call alone between
  /// a NULL message and a missing message body.
  ffi.Pointer<ffi.Char> pactffi_sync_message_get_response_contents_str(
    ffi.Pointer<SynchronousMessage> message,
    int index,
  ) {
    return _pactffi_sync_message_get_response_contents_str(
      message,
      index,
    );
  }

  late final _pactffi_sync_message_get_response_contents_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousMessage>,
              ffi.Size)>>('pactffi_sync_message_get_response_contents_str');
  late final _pactffi_sync_message_get_response_contents_str =
      _pactffi_sync_message_get_response_contents_strPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<SynchronousMessage>, int)>();

  /// Sets the response contents of the message as a string. If index is greater than the number of responses
  /// in the message, the responses will be padded with default values.
  ///
  /// * `message` - the message to set the response contents for
  /// * `index` - index of the response to set. 0 is the first response.
  /// * `contents` - pointer to contents to copy from. Must be a valid NULL-terminated UTF-8 string pointer.
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The message contents and content type must either be NULL pointers, or point to valid
  /// UTF-8 encoded NULL-terminated strings. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the response contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_sync_message_set_response_contents_str(
    ffi.Pointer<SynchronousMessage> message,
    int index,
    ffi.Pointer<ffi.Char> contents,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_sync_message_set_response_contents_str(
      message,
      index,
      contents,
      content_type,
    );
  }

  late final _pactffi_sync_message_set_response_contents_strPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SynchronousMessage>, ffi.Size,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>(
      'pactffi_sync_message_set_response_contents_str');
  late final _pactffi_sync_message_set_response_contents_str =
      _pactffi_sync_message_set_response_contents_strPtr.asFunction<
          void Function(ffi.Pointer<SynchronousMessage>, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Get the length of the response contents of a `SynchronousMessage`.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL or the index is not valid, returns 0. If the body of the request
  /// is missing, then this function also returns 0.
  int pactffi_sync_message_get_response_contents_length(
    ffi.Pointer<SynchronousMessage> message,
    int index,
  ) {
    return _pactffi_sync_message_get_response_contents_length(
      message,
      index,
    );
  }

  late final _pactffi_sync_message_get_response_contents_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<SynchronousMessage>,
              ffi.Size)>>('pactffi_sync_message_get_response_contents_length');
  late final _pactffi_sync_message_get_response_contents_length =
      _pactffi_sync_message_get_response_contents_lengthPtr
          .asFunction<int Function(ffi.Pointer<SynchronousMessage>, int)>();

  /// Get the response contents of a `SynchronousMessage` as a pointer to an array of bytes.
  ///
  /// # Safety
  ///
  /// The number of bytes in the buffer will be returned by `pactffi_sync_message_get_response_contents_length`.
  /// It is safe to use the pointer while the message is not deleted or changed. Using the pointer
  /// after the message is mutated or deleted may lead to undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL or the index is not valid, returns NULL. If the body of the message
  /// is missing, then this function also returns NULL.
  ffi.Pointer<ffi.UnsignedChar> pactffi_sync_message_get_response_contents_bin(
    ffi.Pointer<SynchronousMessage> message,
    int index,
  ) {
    return _pactffi_sync_message_get_response_contents_bin(
      message,
      index,
    );
  }

  late final _pactffi_sync_message_get_response_contents_binPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<SynchronousMessage>,
              ffi.Size)>>('pactffi_sync_message_get_response_contents_bin');
  late final _pactffi_sync_message_get_response_contents_bin =
      _pactffi_sync_message_get_response_contents_binPtr.asFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<SynchronousMessage>, int)>();

  /// Sets the response contents of the message at the given index as an array of bytes. If index
  /// is greater than the number of responses in the message, the responses will be padded with
  /// default values.
  ///
  /// * `message` - the message to set the response contents for
  /// * `index` - index of the response to set. 0 is the first response
  /// * `contents` - pointer to contents to copy from
  /// * `len` - number of bytes to copy
  /// * `content_type` - pointer to the NULL-terminated UTF-8 string containing the content type of the data.
  ///
  /// # Safety
  ///
  /// The contents pointer must be valid for reads of `len` bytes, and it must be properly aligned
  /// and consecutive. Otherwise behaviour is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the message contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will set the content type as unknown.
  void pactffi_sync_message_set_response_contents_bin(
    ffi.Pointer<SynchronousMessage> message,
    int index,
    ffi.Pointer<ffi.UnsignedChar> contents,
    int len,
    ffi.Pointer<ffi.Char> content_type,
  ) {
    return _pactffi_sync_message_set_response_contents_bin(
      message,
      index,
      contents,
      len,
      content_type,
    );
  }

  late final _pactffi_sync_message_set_response_contents_binPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<SynchronousMessage>,
                  ffi.Size,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>)>>(
      'pactffi_sync_message_set_response_contents_bin');
  late final _pactffi_sync_message_set_response_contents_bin =
      _pactffi_sync_message_set_response_contents_binPtr.asFunction<
          void Function(ffi.Pointer<SynchronousMessage>, int,
              ffi.Pointer<ffi.UnsignedChar>, int, ffi.Pointer<ffi.Char>)>();

  /// Get the response contents of an `SynchronousMessage` as a `MessageContents` pointer.
  ///
  /// # Safety
  ///
  /// The data pointed to by the pointer this function returns will be deleted when the message
  /// is deleted. Trying to use if after the message is deleted will result in undefined behaviour.
  ///
  /// # Error Handling
  ///
  /// If the message is NULL or the index is not valid, returns NULL.
  ffi.Pointer<MessageContents> pactffi_sync_message_get_response_contents(
    ffi.Pointer<SynchronousMessage> message,
    int index,
  ) {
    return _pactffi_sync_message_get_response_contents(
      message,
      index,
    );
  }

  late final _pactffi_sync_message_get_response_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<MessageContents> Function(ffi.Pointer<SynchronousMessage>,
              ffi.Size)>>('pactffi_sync_message_get_response_contents');
  late final _pactffi_sync_message_get_response_contents =
      _pactffi_sync_message_get_response_contentsPtr.asFunction<
          ffi.Pointer<MessageContents> Function(
              ffi.Pointer<SynchronousMessage>, int)>();

  /// Generate the response contents of a `SynchronousMessage` as a
  /// `MessageContents` pointer.
  ///
  /// This function differs from
  /// [`pactffi_sync_message_get_response_contents`] in that it will process
  /// the message contents for any generators or matchers that are present in
  /// the message in order to generate the actual message contents as would be
  /// received by the consumer.
  ///
  /// # Safety
  ///
  /// The data pointed to by the pointer must be deleted with
  /// [`pactffi_message_contents_delete`][crate::models::contents::pactffi_message_contents_delete]
  ///
  /// # Error Handling
  ///
  /// If the message is NULL, returns NULL.
  ffi.Pointer<MessageContents> pactffi_sync_message_generate_response_contents(
    ffi.Pointer<SynchronousMessage> message,
    int index,
  ) {
    return _pactffi_sync_message_generate_response_contents(
      message,
      index,
    );
  }

  late final _pactffi_sync_message_generate_response_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<MessageContents> Function(ffi.Pointer<SynchronousMessage>,
              ffi.Size)>>('pactffi_sync_message_generate_response_contents');
  late final _pactffi_sync_message_generate_response_contents =
      _pactffi_sync_message_generate_response_contentsPtr.asFunction<
          ffi.Pointer<MessageContents> Function(
              ffi.Pointer<SynchronousMessage>, int)>();

  /// Get a copy of the description.
  ///
  /// # Safety
  ///
  /// The returned string must be deleted with `pactffi_string_delete`.
  ///
  /// Since it is a copy, the returned string may safely outlive
  /// the `SynchronousMessage`.
  ///
  /// # Errors
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if the Rust string contains embedded
  /// null ('\0') bytes.
  ffi.Pointer<ffi.Char> pactffi_sync_message_get_description(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_get_description(
      message,
    );
  }

  late final _pactffi_sync_message_get_descriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_get_description');
  late final _pactffi_sync_message_get_description =
      _pactffi_sync_message_get_descriptionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<SynchronousMessage>)>();

  /// Write the `description` field on the `SynchronousMessage`.
  ///
  /// # Safety
  ///
  /// `description` must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  ///
  /// This function will only reallocate if the new string
  /// does not fit in the existing buffer.
  ///
  /// # Error Handling
  ///
  /// Errors will be reported with a non-zero return value.
  int pactffi_sync_message_set_description(
    ffi.Pointer<SynchronousMessage> message,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_sync_message_set_description(
      message,
      description,
    );
  }

  late final _pactffi_sync_message_set_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SynchronousMessage>,
              ffi.Pointer<ffi.Char>)>>('pactffi_sync_message_set_description');
  late final _pactffi_sync_message_set_description =
      _pactffi_sync_message_set_descriptionPtr.asFunction<
          int Function(
              ffi.Pointer<SynchronousMessage>, ffi.Pointer<ffi.Char>)>();

  /// Get a copy of the provider state at the given index from this message.
  ///
  /// # Safety
  ///
  /// The returned structure must be deleted with `provider_state_delete`.
  ///
  /// Since it is a copy, the returned structure may safely outlive
  /// the `SynchronousMessage`.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a variant other than Success.
  ///
  /// This function may fail if the index requested is out of bounds,
  /// or if any of the Rust strings contain embedded null ('\0') bytes.
  ffi.Pointer<ProviderState> pactffi_sync_message_get_provider_state(
    ffi.Pointer<SynchronousMessage> message,
    int index,
  ) {
    return _pactffi_sync_message_get_provider_state(
      message,
      index,
    );
  }

  late final _pactffi_sync_message_get_provider_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ProviderState> Function(ffi.Pointer<SynchronousMessage>,
              ffi.UnsignedInt)>>('pactffi_sync_message_get_provider_state');
  late final _pactffi_sync_message_get_provider_state =
      _pactffi_sync_message_get_provider_statePtr.asFunction<
          ffi.Pointer<ProviderState> Function(
              ffi.Pointer<SynchronousMessage>, int)>();

  /// Get an iterator over provider states.
  ///
  /// # Safety
  ///
  /// The underlying data must not change during iteration.
  ///
  /// # Error Handling
  ///
  /// Returns NULL if an error occurs.
  ffi.Pointer<ProviderStateIterator>
      pactffi_sync_message_get_provider_state_iter(
    ffi.Pointer<SynchronousMessage> message,
  ) {
    return _pactffi_sync_message_get_provider_state_iter(
      message,
    );
  }

  late final _pactffi_sync_message_get_provider_state_iterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ProviderStateIterator> Function(
                  ffi.Pointer<SynchronousMessage>)>>(
      'pactffi_sync_message_get_provider_state_iter');
  late final _pactffi_sync_message_get_provider_state_iter =
      _pactffi_sync_message_get_provider_state_iterPtr.asFunction<
          ffi.Pointer<ProviderStateIterator> Function(
              ffi.Pointer<SynchronousMessage>)>();

  /// Delete a string previously returned by this FFI.
  ///
  /// It is explicitly allowed to pass a null pointer to this function;
  /// in that case the function will do nothing.
  ///
  /// # Safety
  /// Passing an invalid pointer, or one that was not returned by a FFI function can result in
  /// undefined behaviour.
  void pactffi_string_delete(
    ffi.Pointer<ffi.Char> string,
  ) {
    return _pactffi_string_delete(
      string,
    );
  }

  late final _pactffi_string_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'pactffi_string_delete');
  late final _pactffi_string_delete = _pactffi_string_deletePtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// [DEPRECATED] External interface to create a HTTP mock server. A pointer to the pact JSON as a NULL-terminated C
  /// string is passed in, as well as the port for the mock server to run on. A value of 0 for the
  /// port will result in a port being allocated by the operating system. The port of the mock server is returned.
  ///
  /// * `pact_str` - Pact JSON
  /// * `addr_str` - Address to bind to in the form name:port (i.e. 127.0.0.1:0)
  /// * `tls` - boolean flag to indicate of the mock server should use TLS (using a self-signed certificate)
  ///
  /// This function is deprecated and replaced with `pactffi_create_mock_server_for_transport`.
  ///
  /// # Errors
  ///
  /// Errors are returned as negative values.
  ///
  /// | Error | Description |
  /// |-------|-------------|
  /// | -1 | A null pointer was received |
  /// | -2 | The pact JSON could not be parsed |
  /// | -3 | The mock server could not be started |
  /// | -4 | The method panicked |
  /// | -5 | The address is not valid |
  /// | -6 | Could not create the TLS configuration with the self-signed certificate |
  int pactffi_create_mock_server(
    ffi.Pointer<ffi.Char> pact_str,
    ffi.Pointer<ffi.Char> addr_str,
    bool tls,
  ) {
    return _pactffi_create_mock_server(
      pact_str,
      addr_str,
      tls,
    );
  }

  late final _pactffi_create_mock_serverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('pactffi_create_mock_server');
  late final _pactffi_create_mock_server =
      _pactffi_create_mock_serverPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, bool)>();

  /// Fetch the CA Certificate used to generate the self-signed certificate for the TLS mock server.
  ///
  /// **NOTE:** The string for the result is allocated on the heap, and will have to be freed
  /// by the caller using pactffi_string_delete.
  ///
  /// # Errors
  ///
  /// An empty string indicates an error reading the pem file.
  ffi.Pointer<ffi.Char> pactffi_get_tls_ca_certificate() {
    return _pactffi_get_tls_ca_certificate();
  }

  late final _pactffi_get_tls_ca_certificatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pactffi_get_tls_ca_certificate');
  late final _pactffi_get_tls_ca_certificate =
      _pactffi_get_tls_ca_certificatePtr
          .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// [DEPRECATED] External interface to create a HTTP mock server. A Pact handle is passed in,
  /// as well as the port for the mock server to run on. A value of 0 for the port will result in a
  /// port being allocated by the operating system. The port of the mock server is returned.
  ///
  /// * `pact` - Handle to a Pact model created with created with `pactffi_new_pact`.
  /// * `addr_str` - Address to bind to in the form name:port (i.e. 127.0.0.1:0). Must be a valid UTF-8 NULL-terminated string.
  /// * `tls` - boolean flag to indicate of the mock server should use TLS (using a self-signed certificate)
  ///
  /// This function is deprecated and replaced with `pactffi_create_mock_server_for_transport`.
  ///
  /// # Errors
  ///
  /// Errors are returned as negative values.
  ///
  /// | Error | Description |
  /// |-------|-------------|
  /// | -1 | An invalid handle was received. Handles should be created with `pactffi_new_pact` |
  /// | -3 | The mock server could not be started |
  /// | -4 | The method panicked |
  /// | -5 | The address is not valid |
  /// | -6 | Could not create the TLS configuration with the self-signed certificate |
  int pactffi_create_mock_server_for_pact(
    int pact,
    ffi.Pointer<ffi.Char> addr_str,
    bool tls,
  ) {
    return _pactffi_create_mock_server_for_pact(
      pact,
      addr_str,
      tls,
    );
  }

  late final _pactffi_create_mock_server_for_pactPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(PactHandle, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('pactffi_create_mock_server_for_pact');
  late final _pactffi_create_mock_server_for_pact =
      _pactffi_create_mock_server_for_pactPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Char>, bool)>();

  /// Create a mock server for the provided Pact handle and transport. If the transport is not
  /// provided (it is a NULL pointer or an empty string), will default to an HTTP transport. The
  /// address is the interface bind to, and will default to the loopback adapter if not specified.
  /// Specifying a value of zero for the port will result in the operating system allocating the port.
  ///
  /// Parameters:
  /// * `pact` - Handle to a Pact model created with created with `pactffi_new_pact`.
  /// * `addr` - Address to bind to (i.e. `127.0.0.1` or `[::1]`). Must be a valid UTF-8 NULL-terminated string, or NULL or empty, in which case the loopback adapter is used.
  /// * `port` - Port number to bind to. A value of zero will result in the operating system allocating an available port.
  /// * `transport` - The transport to use (i.e. http, https, grpc). Must be a valid UTF-8 NULL-terminated string, or NULL or empty, in which case http will be used.
  /// * `transport_config` - (OPTIONAL) Configuration for the transport as a valid JSON string. Set to NULL or empty if not required.
  ///
  /// The port of the mock server is returned.
  ///
  /// # Safety
  /// NULL pointers or empty strings can be passed in for the address, transport and transport_config,
  /// in which case a default value will be used. Passing in an invalid pointer will result in undefined behaviour.
  ///
  /// # Errors
  ///
  /// Errors are returned as negative values.
  ///
  /// | Error | Description |
  /// |-------|-------------|
  /// | -1 | An invalid handle was received. Handles should be created with `pactffi_new_pact` |
  /// | -2 | transport_config is not valid JSON |
  /// | -3 | The mock server could not be started |
  /// | -4 | The method panicked |
  /// | -5 | The address is not valid |
  int pactffi_create_mock_server_for_transport(
    int pact,
    ffi.Pointer<ffi.Char> addr,
    int port,
    ffi.Pointer<ffi.Char> transport,
    ffi.Pointer<ffi.Char> transport_config,
  ) {
    return _pactffi_create_mock_server_for_transport(
      pact,
      addr,
      port,
      transport,
      transport_config,
    );
  }

  late final _pactffi_create_mock_server_for_transportPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(PactHandle, ffi.Pointer<ffi.Char>, ffi.Uint16,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>(
      'pactffi_create_mock_server_for_transport');
  late final _pactffi_create_mock_server_for_transport =
      _pactffi_create_mock_server_for_transportPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// External interface to check if a mock server has matched all its requests. The port number is
  /// passed in, and if all requests have been matched, true is returned. False is returned if there
  /// is no mock server on the given port, or if any request has not been successfully matched, or
  /// the method panics.
  bool pactffi_mock_server_matched(
    int mock_server_port,
  ) {
    return _pactffi_mock_server_matched(
      mock_server_port,
    );
  }

  late final _pactffi_mock_server_matchedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'pactffi_mock_server_matched');
  late final _pactffi_mock_server_matched =
      _pactffi_mock_server_matchedPtr.asFunction<bool Function(int)>();

  /// External interface to get all the mismatches from a mock server. The port number of the mock
  /// server is passed in, and a pointer to a C string with the mismatches in JSON format is
  /// returned.
  ///
  /// **NOTE:** The JSON string for the result is allocated on the heap, and will have to be freed
  /// once the code using the mock server is complete. The [`cleanup_mock_server`](fn.cleanup_mock_server.html) function is
  /// provided for this purpose.
  ///
  /// # Errors
  ///
  /// If there is no mock server with the provided port number, or the function panics, a NULL
  /// pointer will be returned. Don't try to dereference it, it will not end well for you.
  ffi.Pointer<ffi.Char> pactffi_mock_server_mismatches(
    int mock_server_port,
  ) {
    return _pactffi_mock_server_mismatches(
      mock_server_port,
    );
  }

  late final _pactffi_mock_server_mismatchesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'pactffi_mock_server_mismatches');
  late final _pactffi_mock_server_mismatches =
      _pactffi_mock_server_mismatchesPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// External interface to cleanup a mock server. This function will try terminate the mock server
  /// with the given port number and cleanup any memory allocated for it. Returns true, unless a
  /// mock server with the given port number does not exist, or the function panics.
  bool pactffi_cleanup_mock_server(
    int mock_server_port,
  ) {
    return _pactffi_cleanup_mock_server(
      mock_server_port,
    );
  }

  late final _pactffi_cleanup_mock_serverPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'pactffi_cleanup_mock_server');
  late final _pactffi_cleanup_mock_server =
      _pactffi_cleanup_mock_serverPtr.asFunction<bool Function(int)>();

  /// External interface to trigger a mock server to write out its pact file. This function should
  /// be called if all the consumer tests have passed. The directory to write the file to is passed
  /// as the second parameter. If a NULL pointer is passed, the current working directory is used.
  ///
  /// If overwrite is true, the file will be overwritten with the contents of the current pact.
  /// Otherwise, it will be merged with any existing pact file.
  ///
  /// Returns 0 if the pact file was successfully written. Returns a positive code if the file can
  /// not be written, or there is no mock server running on that port or the function panics.
  ///
  /// # Errors
  ///
  /// Errors are returned as positive values.
  ///
  /// | Error | Description |
  /// |-------|-------------|
  /// | 1 | A general panic was caught |
  /// | 2 | The pact file was not able to be written |
  /// | 3 | A mock server with the provided port was not found |
  int pactffi_write_pact_file(
    int mock_server_port,
    ffi.Pointer<ffi.Char> directory,
    bool overwrite,
  ) {
    return _pactffi_write_pact_file(
      mock_server_port,
      directory,
      overwrite,
    );
  }

  late final _pactffi_write_pact_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('pactffi_write_pact_file');
  late final _pactffi_write_pact_file = _pactffi_write_pact_filePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, bool)>();

  /// Fetch the logs for the mock server. This needs the memory buffer log sink to be setup before
  /// the mock server is started. Returned string will be freed with the `cleanup_mock_server`
  /// function call.
  ///
  /// Will return a NULL pointer if the logs for the mock server can not be retrieved.
  ffi.Pointer<ffi.Char> pactffi_mock_server_logs(
    int mock_server_port,
  ) {
    return _pactffi_mock_server_logs(
      mock_server_port,
    );
  }

  late final _pactffi_mock_server_logsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'pactffi_mock_server_logs');
  late final _pactffi_mock_server_logs = _pactffi_mock_server_logsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Generates a datetime value from the provided format string, using the current system date and time
  /// NOTE: The memory for the returned string needs to be freed with the `pactffi_string_delete` function
  ///
  /// # Safety
  ///
  /// If the format string pointer is NULL or has invalid UTF-8 characters, an error result will be
  /// returned. If the format string pointer is not a valid pointer or is not a NULL-terminated string,
  /// this will lead to undefined behaviour.
  StringResult pactffi_generate_datetime_string(
    ffi.Pointer<ffi.Char> format,
  ) {
    return _pactffi_generate_datetime_string(
      format,
    );
  }

  late final _pactffi_generate_datetime_stringPtr =
      _lookup<ffi.NativeFunction<StringResult Function(ffi.Pointer<ffi.Char>)>>(
          'pactffi_generate_datetime_string');
  late final _pactffi_generate_datetime_string =
      _pactffi_generate_datetime_stringPtr
          .asFunction<StringResult Function(ffi.Pointer<ffi.Char>)>();

  /// Checks that the example string matches the given regex.
  ///
  /// # Safety
  ///
  /// Both the regex and example pointers must be valid pointers to NULL-terminated strings. Invalid
  /// pointers will result in undefined behaviour.
  bool pactffi_check_regex(
    ffi.Pointer<ffi.Char> regex,
    ffi.Pointer<ffi.Char> example,
  ) {
    return _pactffi_check_regex(
      regex,
      example,
    );
  }

  late final _pactffi_check_regexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_check_regex');
  late final _pactffi_check_regex = _pactffi_check_regexPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Generates an example string based on the provided regex.
  /// NOTE: The memory for the returned string needs to be freed with the `pactffi_string_delete` function.
  ///
  /// # Safety
  ///
  /// The regex pointer must be a valid pointer to a NULL-terminated string. Invalid pointers will
  /// result in undefined behaviour.
  StringResult pactffi_generate_regex_value(
    ffi.Pointer<ffi.Char> regex,
  ) {
    return _pactffi_generate_regex_value(
      regex,
    );
  }

  late final _pactffi_generate_regex_valuePtr =
      _lookup<ffi.NativeFunction<StringResult Function(ffi.Pointer<ffi.Char>)>>(
          'pactffi_generate_regex_value');
  late final _pactffi_generate_regex_value = _pactffi_generate_regex_valuePtr
      .asFunction<StringResult Function(ffi.Pointer<ffi.Char>)>();

  /// [DEPRECATED] Frees the memory allocated to a string by another function
  ///
  /// This function is deprecated. Use `pactffi_string_delete` instead.
  ///
  /// # Safety
  ///
  /// The string pointer can be NULL (which is a no-op), but if it is not a valid pointer the call
  /// will result in undefined behaviour.
  void pactffi_free_string(
    ffi.Pointer<ffi.Char> s,
  ) {
    return _pactffi_free_string(
      s,
    );
  }

  late final _pactffi_free_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'pactffi_free_string');
  late final _pactffi_free_string = _pactffi_free_stringPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a new Pact model and returns a handle to it.
  ///
  /// * `consumer_name` - The name of the consumer for the pact.
  /// * `provider_name` - The name of the provider for the pact.
  ///
  /// Returns a new `PactHandle`. The handle will need to be freed with the `pactffi_free_pact_handle`
  /// method to release its resources.
  int pactffi_new_pact(
    ffi.Pointer<ffi.Char> consumer_name,
    ffi.Pointer<ffi.Char> provider_name,
  ) {
    return _pactffi_new_pact(
      consumer_name,
      provider_name,
    );
  }

  late final _pactffi_new_pactPtr = _lookup<
      ffi.NativeFunction<
          PactHandle Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_new_pact');
  late final _pactffi_new_pact = _pactffi_new_pactPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Returns a mutable pointer to a Pact model which has been cloned from the Pact handle's inner
  /// Pact model. The returned Pact model must be freed with the `pactffi_pact_model_delete`
  /// function when no longer needed.
  ffi.Pointer<Pact> pactffi_pact_handle_to_pointer(
    int pact,
  ) {
    return _pactffi_pact_handle_to_pointer(
      pact,
    );
  }

  late final _pactffi_pact_handle_to_pointerPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<Pact> Function(PactHandle)>>(
          'pactffi_pact_handle_to_pointer');
  late final _pactffi_pact_handle_to_pointer =
      _pactffi_pact_handle_to_pointerPtr
          .asFunction<ffi.Pointer<Pact> Function(int)>();

  /// Creates a new HTTP Interaction and returns a handle to it. Calling this function with the
  /// same description as an existing interaction will result in that interaction being replaced
  /// with the new one.
  ///
  /// * `description` - The interaction description. It needs to be unique for each interaction.
  ///
  /// Returns a new `InteractionHandle`.
  int pactffi_new_interaction(
    int pact,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_new_interaction(
      pact,
      description,
    );
  }

  late final _pactffi_new_interactionPtr = _lookup<
      ffi.NativeFunction<
          InteractionHandle Function(
              PactHandle, ffi.Pointer<ffi.Char>)>>('pactffi_new_interaction');
  late final _pactffi_new_interaction = _pactffi_new_interactionPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Creates a new message interaction and returns a handle to it. Calling this function with the
  /// same description as an existing interaction will result in that interaction being replaced
  /// with the new one.
  ///
  /// * `description` - The interaction description. It needs to be unique for each interaction.
  ///
  /// Returns a new `InteractionHandle`.
  int pactffi_new_message_interaction(
    int pact,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_new_message_interaction(
      pact,
      description,
    );
  }

  late final _pactffi_new_message_interactionPtr = _lookup<
      ffi.NativeFunction<
          InteractionHandle Function(PactHandle,
              ffi.Pointer<ffi.Char>)>>('pactffi_new_message_interaction');
  late final _pactffi_new_message_interaction =
      _pactffi_new_message_interactionPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Creates a new synchronous message interaction (request/response) and returns a handle to it.
  /// Calling this function with the same description as an existing interaction will result in
  /// that interaction being replaced with the new one.
  ///
  /// * `description` - The interaction description. It needs to be unique for each interaction.
  ///
  /// Returns a new `InteractionHandle`.
  int pactffi_new_sync_message_interaction(
    int pact,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_new_sync_message_interaction(
      pact,
      description,
    );
  }

  late final _pactffi_new_sync_message_interactionPtr = _lookup<
      ffi.NativeFunction<
          InteractionHandle Function(PactHandle,
              ffi.Pointer<ffi.Char>)>>('pactffi_new_sync_message_interaction');
  late final _pactffi_new_sync_message_interaction =
      _pactffi_new_sync_message_interactionPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the description for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `description` - The interaction description. It needs to be unique for each interaction.
  bool pactffi_upon_receiving(
    int interaction,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_upon_receiving(
      interaction,
      description,
    );
  }

  late final _pactffi_upon_receivingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle,
              ffi.Pointer<ffi.Char>)>>('pactffi_upon_receiving');
  late final _pactffi_upon_receiving = _pactffi_upon_receivingPtr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Char>)>();

  /// Adds a provider state to the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `description` - The provider state description. It needs to be unique.
  bool pactffi_given(
    int interaction,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_given(
      interaction,
      description,
    );
  }

  late final _pactffi_givenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle, ffi.Pointer<ffi.Char>)>>('pactffi_given');
  late final _pactffi_given =
      _pactffi_givenPtr.asFunction<bool Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the test name annotation for the interaction. This allows capturing the name of
  /// the test as metadata. This can only be used with V4 interactions.
  ///
  /// # Safety
  ///
  /// The test name parameter must be a valid pointer to a NULL terminated string.
  ///
  /// # Error Handling
  ///
  /// If the test name can not be set, this will return a positive value.
  ///
  /// * `1` - Function panicked. Error message will be available by calling `pactffi_get_error_message`.
  /// * `2` - Handle was not valid.
  /// * `3` - Mock server was already started and the integration can not be modified.
  /// * `4` - Not a V4 interaction.
  int pactffi_interaction_test_name(
    int interaction,
    ffi.Pointer<ffi.Char> test_name,
  ) {
    return _pactffi_interaction_test_name(
      interaction,
      test_name,
    );
  }

  late final _pactffi_interaction_test_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(InteractionHandle,
              ffi.Pointer<ffi.Char>)>>('pactffi_interaction_test_name');
  late final _pactffi_interaction_test_name = _pactffi_interaction_test_namePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Adds a parameter key and value to a provider state to the Interaction. If the provider state
  /// does not exist, a new one will be created, otherwise the parameter will be merged into the
  /// existing one. The parameter value will be parsed as JSON.
  ///
  /// Returns false if the interaction or Pact can't be modified (i.e. the mock server for it has
  /// already started).
  ///
  /// # Parameters
  /// * `description` - The provider state description. It needs to be unique.
  /// * `name` - Parameter name.
  /// * `value` - Parameter value as JSON.
  bool pactffi_given_with_param(
    int interaction,
    ffi.Pointer<ffi.Char> description,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_given_with_param(
      interaction,
      description,
      name,
      value,
    );
  }

  late final _pactffi_given_with_paramPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_given_with_param');
  late final _pactffi_given_with_param =
      _pactffi_given_with_paramPtr.asFunction<
          bool Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Adds a provider state to the Interaction with a set of parameter key and value pairs in JSON
  /// form. If the params is not an JSON object, it will add it as a single parameter with a `value`
  /// key.
  ///
  /// # Parameters
  /// * `description` - The provider state description.
  /// * `params` - Parameter values as a JSON fragment.
  ///
  /// # Errors
  /// Returns EXIT_FAILURE (1) if the interaction or Pact can't be modified (i.e. the mock server
  /// for it has already started).
  /// Returns 2 and sets the error message (which can be retrieved with `pactffi_get_error_message`)
  /// if the parameter values con't be parsed as JSON.
  /// Returns 3 if any of the C strings are not valid.
  int pactffi_given_with_params(
    int interaction,
    ffi.Pointer<ffi.Char> description,
    ffi.Pointer<ffi.Char> params,
  ) {
    return _pactffi_given_with_params(
      interaction,
      description,
      params,
    );
  }

  late final _pactffi_given_with_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(InteractionHandle, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_given_with_params');
  late final _pactffi_given_with_params =
      _pactffi_given_with_paramsPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Configures the request for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `method` - The request method. Defaults to GET.
  /// * `path` - The request path. Defaults to `/`.
  ///
  /// To include matching rules for the path (only regex really makes sense to use), include the
  /// matching rule JSON format with the value as a single JSON document. I.e.
  ///
  /// ```c
  /// const char* value = "{\"value\":\"/path/to/100\", \"pact:matcher:type\":\"regex\", \"regex\":\"\\/path\\/to\\/\\\\d+\"}";
  /// pactffi_with_request(handle, "GET", value);
  /// ```
  /// See [IntegrationJson.md](https://github.com/pact-foundation/pact-reference/blob/master/rust/pact_ffi/IntegrationJson.md)
  bool pactffi_with_request(
    int interaction,
    ffi.Pointer<ffi.Char> method,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _pactffi_with_request(
      interaction,
      method,
      path,
    );
  }

  late final _pactffi_with_requestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_request');
  late final _pactffi_with_request = _pactffi_with_requestPtr.asFunction<
      bool Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Configures a query parameter for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `name` - the query parameter name.
  /// * `value` - the query parameter value.
  /// * `index` - the index of the value (starts at 0). You can use this to create a query parameter with multiple values
  ///
  /// **DEPRECATED:** Use `pactffi_with_query_parameter_v2`, which deals with multiple values correctly
  bool pactffi_with_query_parameter(
    int interaction,
    ffi.Pointer<ffi.Char> name,
    int index,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_with_query_parameter(
      interaction,
      name,
      index,
      value,
    );
  }

  late final _pactffi_with_query_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle, ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_query_parameter');
  late final _pactffi_with_query_parameter =
      _pactffi_with_query_parameterPtr.asFunction<
          bool Function(
              int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Configures a query parameter for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `name` - the query parameter name.
  /// * `value` - the query parameter value. Either a simple string or a JSON document.
  /// * `index` - the index of the value (starts at 0). You can use this to create a query parameter with multiple values
  ///
  /// To setup a query parameter with multiple values, you can either call this function multiple times
  /// with a different index value, i.e. to create `id=2&id=3`
  ///
  /// ```c
  /// pactffi_with_query_parameter_v2(handle, "id", 0, "2");
  /// pactffi_with_query_parameter_v2(handle, "id", 1, "3");
  /// ```
  ///
  /// Or you can call it once with a JSON value that contains multiple values:
  ///
  /// ```c
  /// const char* value = "{\"value\": [\"2\",\"3\"]}";
  /// pactffi_with_query_parameter_v2(handle, "id", 0, value);
  /// ```
  ///
  /// To include matching rules for the query parameter, include the matching rule JSON format with
  /// the value as a single JSON document. I.e.
  ///
  /// ```c
  /// const char* value = "{\"value\":\"2\", \"pact:matcher:type\":\"regex\", \"regex\":\"\\\\d+\"}";
  /// pactffi_with_query_parameter_v2(handle, "id", 0, value);
  /// ```
  /// See [IntegrationJson.md](https://github.com/pact-foundation/pact-reference/blob/master/rust/pact_ffi/IntegrationJson.md)
  ///
  /// If you want the matching rules to apply to all values (and not just the one with the given
  /// index), make sure to set the value to be an array.
  ///
  /// ```c
  /// const char* value = "{\"value\":[\"2\"], \"pact:matcher:type\":\"regex\", \"regex\":\"\\\\d+\"}";
  /// pactffi_with_query_parameter_v2(handle, "id", 0, value);
  /// ```
  ///
  /// For query parameters with no value, two distinct formats are provided:
  ///
  /// 1. Parameters with blank values, as specified by `?foo=&bar=`, require an empty string:
  ///
  /// ```c
  /// pactffi_with_query_parameter_v2(handle, "foo", 0, "");
  /// pactffi_with_query_parameter_v2(handle, "bar", 0, "");
  /// ```
  ///
  /// 2. Parameters with no associated value, as specified by `?foo&bar`, require a NULL pointer:
  ///
  /// ```c
  /// pactffi_with_query_parameter_v2(handle, "foo", 0, NULL);
  /// pactffi_with_query_parameter_v2(handle, "bar", 0, NULL);
  /// ```
  ///
  /// # Safety
  /// The name parameter must be a valid pointer to a NULL terminated string. If the value
  /// parameter is not NULL, it must point to a valid NULL terminated string.
  /// ```
  bool pactffi_with_query_parameter_v2(
    int interaction,
    ffi.Pointer<ffi.Char> name,
    int index,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_with_query_parameter_v2(
      interaction,
      name,
      index,
      value,
    );
  }

  late final _pactffi_with_query_parameter_v2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle, ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_query_parameter_v2');
  late final _pactffi_with_query_parameter_v2 =
      _pactffi_with_query_parameter_v2Ptr.asFunction<
          bool Function(
              int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Sets the specification version for a given Pact model. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started) or the version is invalid.
  ///
  /// * `pact` - Handle to a Pact model
  /// * `version` - the spec version to use
  bool pactffi_with_specification(
    DartPactHandle pact,
    PactSpecification version,
  ) {
    return _pactffi_with_specification(
      pact,
      version.value,
    );
  }

  late final _pactffi_with_specificationPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(PactHandle, ffi.UnsignedInt)>>(
      'pactffi_with_specification');
  late final _pactffi_with_specification =
      _pactffi_with_specificationPtr.asFunction<bool Function(int, int)>();

  /// Returns the Pact specification enum that the Pact is for.
  PactSpecification pactffi_handle_get_pact_spec_version(
    DartPactHandle pact,
  ) {
    return PactSpecification.fromValue(_pactffi_handle_get_pact_spec_version(
      pact,
    ));
  }

  late final _pactffi_handle_get_pact_spec_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(PactHandle)>>(
          'pactffi_handle_get_pact_spec_version');
  late final _pactffi_handle_get_pact_spec_version =
      _pactffi_handle_get_pact_spec_versionPtr.asFunction<int Function(int)>();

  /// Sets the additional metadata on the Pact file. Common uses are to add the client library
  /// details such as the name and version. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started) or the namespace is readonly.
  ///
  /// * `pact` - Handle to a Pact model
  /// * `namespace` - the top level metadata key to set any key values on
  /// * `name` - the key to set
  /// * `value` - the value to set
  bool pactffi_with_pact_metadata(
    int pact,
    ffi.Pointer<ffi.Char> namespace_,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_with_pact_metadata(
      pact,
      namespace_,
      name,
      value,
    );
  }

  late final _pactffi_with_pact_metadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              PactHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_pact_metadata');
  late final _pactffi_with_pact_metadata =
      _pactffi_with_pact_metadataPtr.asFunction<
          bool Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Adds metadata to the interaction.
  ///
  /// Metadata is only relevant for message interactions to provide additional
  /// information about the message, such as the queue name, message type, tags,
  /// timestamps, etc.
  ///
  /// * `key` - metadata key
  /// * `value` - metadata value, supports JSON structures with matchers and
  /// generators. Passing a `NULL` point will remove the metadata key instead.
  /// * `part` - the part of the interaction to add the metadata to (only
  /// relevant for synchronous message interactions).
  ///
  /// Returns `true` if the metadata was added successfully, `false` otherwise.
  ///
  /// To include matching rules for the value, include the matching rule JSON
  /// format with the value as a single JSON document. I.e.
  ///
  /// ```c
  /// const char* value = "{\"value\": { \"ID\": \"sjhdjkshsdjh\", \"weight\": 100.5 }, \"pact:matcher:type\":\"type\"}";
  /// pactffi_message_with_metadata_v2(handle, "TagData", value);
  /// ```
  ///
  /// See
  /// [IntegrationJson.md](https://github.com/pact-foundation/pact-reference/blob/master/rust/pact_ffi/IntegrationJson.md)
  ///
  /// # Note
  ///
  /// For HTTP interactions, use [`pactffi_with_header_v2`] instead. This
  /// function will not have any effect on HTTP interactions and returns
  /// `false`.
  ///
  /// For synchronous message interactions, the `part` parameter is required to
  /// specify whether the metadata should be added to the request or response
  /// part. For responses which can have multiple messages, the metadata will be
  /// set on all response messages. This also requires for responses to have
  /// been defined in the interaction.
  ///
  /// The [`pactffi_with_body`] will also contribute to the metadata of the
  /// message (both sync and async) by setting the key `contentType` with the
  /// content type of the message.
  ///
  /// # Safety
  ///
  /// The key and value parameters must be valid pointers to NULL terminated
  /// strings, or `NULL` for the value parameter if the metadata key should be
  /// removed.
  bool pactffi_with_metadata(
    DartInteractionHandle interaction,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    InteractionPart part,
  ) {
    return _pactffi_with_metadata(
      interaction,
      key,
      value,
      part.value,
    );
  }

  late final _pactffi_with_metadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('pactffi_with_metadata');
  late final _pactffi_with_metadata = _pactffi_with_metadataPtr.asFunction<
      bool Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Configures a header for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `part` - The part of the interaction to add the header to (Request or Response).
  /// * `name` - the header name.
  /// * `value` - the header value.
  /// * `index` - the index of the value (starts at 0). You can use this to create a header with multiple values
  ///
  /// **DEPRECATED:** Use `pactffi_with_header_v2`, which deals with multiple values correctly
  bool pactffi_with_header(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> name,
    int index,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_with_header(
      interaction,
      part.value,
      name,
      index,
      value,
    );
  }

  late final _pactffi_with_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_header');
  late final _pactffi_with_header = _pactffi_with_headerPtr.asFunction<
      bool Function(
          int, int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Configures a header for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `part` - The part of the interaction to add the header to (Request or Response).
  /// * `name` - the header name.
  /// * `value` - the header value.
  /// * `index` - the index of the value (starts at 0). You can use this to create a header with multiple values
  ///
  /// To setup a header with multiple values, you can either call this function multiple times
  /// with a different index value, i.e. to create `x-id=2, 3`
  ///
  /// ```c
  /// pactffi_with_header_v2(handle, InteractionPart::Request, "x-id", 0, "2");
  /// pactffi_with_header_v2(handle, InteractionPart::Request, "x-id", 1, "3");
  /// ```
  ///
  /// Or you can call it once with a JSON value that contains multiple values:
  ///
  /// ```c
  /// const char* value = "{\"value\": [\"2\",\"3\"]}";
  /// pactffi_with_header_v2(handle, InteractionPart::Request, "x-id", 0, value);
  /// ```
  ///
  /// To include matching rules for the header, include the matching rule JSON format with
  /// the value as a single JSON document. I.e.
  ///
  /// ```c
  /// const char* value = "{\"value\":\"2\", \"pact:matcher:type\":\"regex\", \"regex\":\"\\\\d+\"}";
  /// pactffi_with_header_v2(handle, InteractionPart::Request, "id", 0, value);
  /// ```
  /// See [IntegrationJson.md](https://github.com/pact-foundation/pact-reference/blob/master/rust/pact_ffi/IntegrationJson.md)
  ///
  /// NOTE: If you pass in a form with multiple values, the index will be ignored.
  ///
  /// # Safety
  /// The name and value parameters must be valid pointers to NULL terminated strings.
  bool pactffi_with_header_v2(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> name,
    int index,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_with_header_v2(
      interaction,
      part.value,
      name,
      index,
      value,
    );
  }

  late final _pactffi_with_header_v2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_header_v2');
  late final _pactffi_with_header_v2 = _pactffi_with_header_v2Ptr.asFunction<
      bool Function(
          int, int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Sets a header for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started). Note that this function will
  /// overwrite any previously set header values. Also, this function will not process the value in
  /// any way, so matching rules and generators can not be configured with it.
  ///
  /// If matching rules are required to be set, use `pactffi_with_header_v2`.
  ///
  /// * `part` - The part of the interaction to add the header to (Request or Response).
  /// * `name` - the header name.
  /// * `value` - the header value.
  ///
  /// # Safety
  /// The name and value parameters must be valid pointers to NULL terminated strings.
  bool pactffi_set_header(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_set_header(
      interaction,
      part.value,
      name,
      value,
    );
  }

  late final _pactffi_set_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_set_header');
  late final _pactffi_set_header = _pactffi_set_headerPtr.asFunction<
      bool Function(int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Configures the response for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `status` - the response status. Defaults to 200.
  bool pactffi_response_status(
    int interaction,
    int status,
  ) {
    return _pactffi_response_status(
      interaction,
      status,
    );
  }

  late final _pactffi_response_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle,
              ffi.UnsignedShort)>>('pactffi_response_status');
  late final _pactffi_response_status =
      _pactffi_response_statusPtr.asFunction<bool Function(int, int)>();

  /// Configures the response for the Interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `status` - the response status. Defaults to 200.
  ///
  /// To include matching rules for the status (only statusCode or integer really makes sense to use), include the
  /// matching rule JSON format with the value as a single JSON document. I.e.
  ///
  /// ```c
  /// const char* status = "{ \"pact:generator:type\": \"RandomInt\", \"min\": 100, \"max\": 399, \"pact:matcher:type\":\"statusCode\", \"status\": \"nonError\"}";
  /// pactffi_response_status_v2(handle, status);
  /// ```
  /// See [IntegrationJson.md](https://github.com/pact-foundation/pact-reference/blob/master/rust/pact_ffi/IntegrationJson.md)
  ///
  /// # Safety
  /// The status parameter must be valid pointers to NULL terminated strings.
  bool pactffi_response_status_v2(
    int interaction,
    ffi.Pointer<ffi.Char> status,
  ) {
    return _pactffi_response_status_v2(
      interaction,
      status,
    );
  }

  late final _pactffi_response_status_v2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle,
              ffi.Pointer<ffi.Char>)>>('pactffi_response_status_v2');
  late final _pactffi_response_status_v2 = _pactffi_response_status_v2Ptr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Char>)>();

  /// Adds the body for the interaction. Returns false if the interaction or Pact
  /// can't be modified (i.e. the mock server for it has already started)
  ///
  /// * `part` - The part of the interaction to add the body to (Request or
  /// Response). This is ignored for asynchronous message interactions.
  /// * `content_type` - The content type of the body, or `NULL` to use the
  /// internal logic.
  /// * `body` - The body contents. For JSON payloads, matching rules can be
  /// embedded in the body. See
  /// [IntegrationJson.md](https://github.com/pact-foundation/pact-reference/blob/master/rust/pact_ffi/IntegrationJson.md)
  ///
  /// If the `content_type` is determined as follows, whichever is first:
  ///
  /// - The `content_type` argument to this function
  /// - The `Content-Type` header for HTTP interaction, or `contentType` metadata
  /// entry for message interactions.
  /// - From automatic detection of the body contents.
  /// - Defaults to `text/plain` as a last resort.
  ///
  /// Furthermore, the `Content-Type` header or `contentType` metadata entry will
  /// be updated with the above determined content type, _unless_ it is already
  /// set.
  ///
  /// This function will overwrite the body contents if they exist, with the
  /// exception of the response part of synchronous message interactions, where a
  /// new response will be appended.
  ///
  /// # Safety
  ///
  /// The interaction contents and content type must either be NULL pointers, or
  /// point to valid UTF-8 encoded NULL-terminated strings. Otherwise, behaviour
  /// is undefined.
  ///
  /// # Error Handling
  ///
  /// If the contents is a NULL pointer, it will set the body contents as null. If
  /// the content type is a null pointer, or can't be parsed, it will set the
  /// content type as TEXT. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started) or an error has
  /// occurred.
  bool pactffi_with_body(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> content_type,
    ffi.Pointer<ffi.Char> body,
  ) {
    return _pactffi_with_body(
      interaction,
      part.value,
      content_type,
      body,
    );
  }

  late final _pactffi_with_bodyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_body');
  late final _pactffi_with_body = _pactffi_with_bodyPtr.asFunction<
      bool Function(int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Adds the body for the interaction. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `part` - The part of the interaction to add the body to (Request or Response).
  /// * `content_type` - The content type of the body. Defaults to `application/octet-stream` if it
  /// is NULL. Will be ignored if a content type header is already set.
  /// * `body` - Body contents as a pointer to a byte array
  /// * `size` - Number of bytes in the body
  ///
  /// For HTTP and async message interactions, this will overwrite the body. With asynchronous messages, the
  /// part parameter will be ignored. With synchronous messages, the request contents will be overwritten,
  /// while a new response will be appended to the message.
  ///
  /// # Safety
  ///
  /// This function is safe to use as long as the following conditions are true:
  /// The content type must either be a NULL pointer, or point to valid UTF-8 encoded NULL-terminated
  /// string. The body pointer must be valid for reads of `size` bytes, and it must be properly
  /// aligned and consecutive (that just means it must point a continuous array of at least `size`
  /// bytes that can be read in a single operation and not to non-continuous structures like linked
  /// lists, etc.).
  ///
  /// # Error Handling
  ///
  /// If the body is a NULL pointer, it will set the body contents as empty. If the content
  /// type is a null pointer, it will set the content type as `application/octet-stream`.
  /// Returns false if the interaction or Pact can't be modified (i.e. the mock server for it has
  /// already started) or an error has occurred.
  bool pactffi_with_binary_body(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> content_type,
    ffi.Pointer<ffi.Uint8> body,
    int size,
  ) {
    return _pactffi_with_binary_body(
      interaction,
      part.value,
      content_type,
      body,
      size,
    );
  }

  late final _pactffi_with_binary_bodyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('pactffi_with_binary_body');
  late final _pactffi_with_binary_body =
      _pactffi_with_binary_bodyPtr.asFunction<
          bool Function(
              int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Uint8>, int)>();

  /// <div class="warning">
  ///
  /// This function is deprecated. Use [`pactffi_with_binary_body`] in order to
  /// set the binary body, and use [`pactffi_with_matching_rules`] to set the
  /// matching rules to ensure that only the content type is being matched.
  ///
  /// </div>
  ///
  /// Adds a binary file as the body with the expected content type and example contents. Will use
  /// a mime type matcher to match the body. Returns false if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started)
  ///
  /// * `interaction` - Interaction handle to set the body for.
  /// * `part` - Request or response part.
  /// * `content_type` - Expected content type.
  /// * `body` - example body contents in bytes
  /// * `size` - number of bytes in the body
  ///
  /// For HTTP and async message interactions, this will overwrite the body. With asynchronous messages, the
  /// part parameter will be ignored. With synchronous messages, the request contents will be overwritten,
  /// while a new response will be appended to the message.
  ///
  /// # Safety
  ///
  /// The content type must be a valid UTF-8 encoded NULL-terminated string. The body pointer must
  /// be valid for reads of `size` bytes, and it must be properly aligned and consecutive.
  ///
  /// # Error Handling
  ///
  /// If the body is a NULL pointer, it will set the body contents as null. If the content
  /// type is a null pointer, or can't be parsed, it will return false.
  /// Returns false if the interaction or Pact can't be modified (i.e. the mock server for it has
  /// already started) or an error has occurred.
  bool pactffi_with_binary_file(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> content_type,
    ffi.Pointer<ffi.Uint8> body,
    int size,
  ) {
    return _pactffi_with_binary_file(
      interaction,
      part.value,
      content_type,
      body,
      size,
    );
  }

  late final _pactffi_with_binary_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('pactffi_with_binary_file');
  late final _pactffi_with_binary_file =
      _pactffi_with_binary_filePtr.asFunction<
          bool Function(
              int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Add matching rules to the interaction.
  ///
  /// * `interaction` - Interaction handle to set the matching rules for.
  /// * `part` - Request or response part (if applicable).
  /// * `rules` - JSON string of the matching rules to add to the interaction.
  ///
  /// This function can be called multiple times, in which case the matching
  /// rules will be merged. The function will return `true` if the rules were
  /// successfully added, and `false` if an error occurred.
  ///
  /// For synchronous messages which allow multiple responses, the matching
  /// rules will be added to all the responses.
  ///
  /// # Safety
  ///
  /// The rules parameter must be a valid pointer to a NULL terminated UTF-8
  /// string.
  bool pactffi_with_matching_rules(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> rules,
  ) {
    return _pactffi_with_matching_rules(
      interaction,
      part.value,
      rules,
    );
  }

  late final _pactffi_with_matching_rulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle, ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_matching_rules');
  late final _pactffi_with_matching_rules = _pactffi_with_matching_rulesPtr
      .asFunction<bool Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Add generators to the interaction.
  ///
  /// * `interaction` - Interaction handle to set the generators for.
  /// * `part` - Request or response part (if applicable).
  /// * `generators` - JSON string of the generators to add to the interaction.
  ///
  /// This function can be called multiple times, in which case the generators
  /// will be combined (provided they don't clash). The function will return
  /// `true` if the rules were successfully added, and `false` if an error
  /// occurred.
  ///
  /// For synchronous messages which allow multiple responses, the generators
  /// will be added to all the responses.
  ///
  /// # Safety
  ///
  /// The generators parameter must be a valid pointer to a NULL terminated
  /// UTF-8 string.
  bool pactffi_with_generators(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> generators,
  ) {
    return _pactffi_with_generators(
      interaction,
      part.value,
      generators,
    );
  }

  late final _pactffi_with_generatorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle, ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_generators');
  late final _pactffi_with_generators = _pactffi_with_generatorsPtr
      .asFunction<bool Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Adds a binary file as the body as a MIME multipart with the expected content type and example contents. Will use
  /// a mime type matcher to match the body. Returns an error if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started) or an error occurs.
  ///
  /// * `interaction` - Interaction handle to set the body for.
  /// * `part` - Request or response part.
  /// * `content_type` - Expected content type of the file.
  /// * `file` - path to the example file
  /// * `part_name` - name for the mime part
  /// * `boundary` - boundary for the multipart separation
  ///
  /// This function can be called multiple times. In that case, each subsequent call will be
  /// appended to the existing multipart body as a new part.
  ///
  /// # Safety
  ///
  /// The content type, file path and part name must be valid pointers to UTF-8 encoded NULL-terminated strings.
  /// Passing invalid pointers or pointers to strings that are not NULL terminated will lead to undefined
  /// behaviour.
  ///
  /// # Error Handling
  ///
  /// If the boundary is a NULL pointer, a random string will be used.
  /// If the file path is a NULL pointer, it will set the body contents as as an empty mime-part.
  /// If the file path does not point to a valid file, or is not able to be read, it will return an
  /// error result. If the content type is a null pointer, or can't be parsed, it will return an error result.
  /// Returns an error if the interaction or Pact can't be modified (i.e. the mock server for it has
  /// already started), the interaction is not an HTTP interaction or some other error occurs.
  StringResult pactffi_with_multipart_file_v2(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> content_type,
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> part_name,
    ffi.Pointer<ffi.Char> boundary,
  ) {
    return _pactffi_with_multipart_file_v2(
      interaction,
      part.value,
      content_type,
      file,
      part_name,
      boundary,
    );
  }

  late final _pactffi_with_multipart_file_v2Ptr = _lookup<
      ffi.NativeFunction<
          StringResult Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_multipart_file_v2');
  late final _pactffi_with_multipart_file_v2 =
      _pactffi_with_multipart_file_v2Ptr.asFunction<
          StringResult Function(
              int,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Adds a binary file as the body as a MIME multipart with the expected content type and example contents. Will use
  /// a mime type matcher to match the body. Returns an error if the interaction or Pact can't be
  /// modified (i.e. the mock server for it has already started) or an error occurs.
  ///
  /// * `interaction` - Interaction handle to set the body for.
  /// * `part` - Request or response part.
  /// * `content_type` - Expected content type of the file.
  /// * `file` - path to the example file
  /// * `part_name` - name for the mime part
  ///
  /// This function can be called multiple times. In that case, each subsequent call will be
  /// appended to the existing multipart body as a new part.
  ///
  /// # Safety
  ///
  /// The content type, file path and part name must be valid pointers to UTF-8 encoded NULL-terminated strings.
  /// Passing invalid pointers or pointers to strings that are not NULL terminated will lead to undefined
  /// behaviour.
  ///
  /// # Error Handling
  ///
  /// If the file path is a NULL pointer, it will set the body contents as as an empty mime-part.
  /// If the file path does not point to a valid file, or is not able to be read, it will return an
  /// error result. If the content type is a null pointer, or can't be parsed, it will return an error result.
  /// Returns an error if the interaction or Pact can't be modified (i.e. the mock server for it has
  /// already started), the interaction is not an HTTP interaction or some other error occurs.
  StringResult pactffi_with_multipart_file(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> content_type,
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> part_name,
  ) {
    return _pactffi_with_multipart_file(
      interaction,
      part.value,
      content_type,
      file,
      part_name,
    );
  }

  late final _pactffi_with_multipart_filePtr = _lookup<
      ffi.NativeFunction<
          StringResult Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_multipart_file');
  late final _pactffi_with_multipart_file =
      _pactffi_with_multipart_filePtr.asFunction<
          StringResult Function(int, int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Sets the key attribute for the interaction.
  ///
  /// * `interaction` - Interaction handle to modify.
  /// * `value` - Key value. This must be a valid UTF-8 null-terminated string,
  /// or NULL to clear the key.
  ///
  /// This function will return `true` if the key was successfully updated.
  ///
  /// # Safety
  ///
  /// The key parameter must be a valid pointer to a NULL terminated UTF-8, or
  /// NULL if the key is to be cleared.
  bool pactffi_set_key(
    int interaction,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_set_key(
      interaction,
      value,
    );
  }

  late final _pactffi_set_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              InteractionHandle, ffi.Pointer<ffi.Char>)>>('pactffi_set_key');
  late final _pactffi_set_key = _pactffi_set_keyPtr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Char>)>();

  /// Mark the interaction as pending.
  ///
  /// * `interaction` - Interaction handle to modify.
  /// * `pending` - Boolean value to toggle the pending state of the interaction.
  ///
  /// This function will return `true` if the key was successfully updated.
  bool pactffi_set_pending(
    int interaction,
    bool pending,
  ) {
    return _pactffi_set_pending(
      interaction,
      pending,
    );
  }

  late final _pactffi_set_pendingPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(InteractionHandle, ffi.Bool)>>(
      'pactffi_set_pending');
  late final _pactffi_set_pending =
      _pactffi_set_pendingPtr.asFunction<bool Function(int, bool)>();

  /// Add a comment to the interaction.
  ///
  /// * `interaction` - Interaction handle to set the comments for.
  /// * `key` - Key value
  /// * `value` - Comment value. This may be any valid JSON value, or a NULL to
  /// clear the comment.
  ///
  /// This function will return `true` if the comments were successfully
  /// updated. Both `key` and `value` must be valid UTF-8 null-terminated
  /// strings; or in the case of `value`, it may also be a NULL pointer in which
  /// case the comment will be cleared.
  ///
  /// Note that a `value` that deserialize to a JSON null will result in a
  /// comment being added, with the value being the JSON null.
  ///
  /// Note that the `text` key is special and is used by
  /// [`pactffi_add_text_comment`] to append comments to the array of comments.
  /// Overwriting the `text` key is allowed, but should be done with caution.
  ///
  /// # Safety
  ///
  /// The key parameter must be a valid pointer to a NULL terminated UTF-8.
  /// The value parameter must be a valid pointer to a NULL terminated UTF-8,
  /// or NULL if the comment is to be cleared.
  bool pactffi_set_comment(
    int interaction,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_set_comment(
      interaction,
      key,
      value,
    );
  }

  late final _pactffi_set_commentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_set_comment');
  late final _pactffi_set_comment = _pactffi_set_commentPtr.asFunction<
      bool Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Add a text comment to the interaction.
  ///
  /// * `interaction` - Interaction handle to set the comments for.
  /// * `comment` - Comment value.
  ///
  /// This function will return `true` if the comments were successfully
  /// updated. The `comment` must be a valid UTF-8 null-terminated string.
  ///
  /// Unlike [`pactffi_set_comment`], this function will always append the
  /// comment to the array of comments under the `text` key.
  ///
  /// If, for any reason, the `text` key is not present or the associated
  /// value not an array, it will be created as/replaced by an array and the
  /// comment will be appended to it.
  ///
  /// # Safety
  ///
  /// The comment parameter must be a valid pointer to a NULL terminated UTF-8.
  bool pactffi_add_text_comment(
    int interaction,
    ffi.Pointer<ffi.Char> comment,
  ) {
    return _pactffi_add_text_comment(
      interaction,
      comment,
    );
  }

  late final _pactffi_add_text_commentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(InteractionHandle,
              ffi.Pointer<ffi.Char>)>>('pactffi_add_text_comment');
  late final _pactffi_add_text_comment = _pactffi_add_text_commentPtr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Char>)>();

  /// Get an iterator over all the messages of the Pact. The returned iterator needs to be
  /// freed with `pactffi_pact_message_iter_delete`.
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the Pact, so it is always safe to use.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain embedded
  /// null ('\0') bytes.
  ffi.Pointer<PactMessageIterator> pactffi_pact_handle_get_message_iter(
    int pact,
  ) {
    return _pactffi_pact_handle_get_message_iter(
      pact,
    );
  }

  late final _pactffi_pact_handle_get_message_iterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<PactMessageIterator> Function(
              PactHandle)>>('pactffi_pact_handle_get_message_iter');
  late final _pactffi_pact_handle_get_message_iter =
      _pactffi_pact_handle_get_message_iterPtr
          .asFunction<ffi.Pointer<PactMessageIterator> Function(int)>();

  /// Get an iterator over all the asynchronous messages of the Pact.
  /// The returned iterator needs to be freed with `pactffi_pact_async_message_iter_delete`.
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the Pact, so it is always safe to use.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain embedded
  /// null ('\0') bytes.
  ffi.Pointer<PactAsyncMessageIterator>
      pactffi_pact_handle_get_async_message_iter(
    int pact,
  ) {
    return _pactffi_pact_handle_get_async_message_iter(
      pact,
    );
  }

  late final _pactffi_pact_handle_get_async_message_iterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<PactAsyncMessageIterator> Function(
              PactHandle)>>('pactffi_pact_handle_get_async_message_iter');
  late final _pactffi_pact_handle_get_async_message_iter =
      _pactffi_pact_handle_get_async_message_iterPtr
          .asFunction<ffi.Pointer<PactAsyncMessageIterator> Function(int)>();

  /// Get an iterator over all the synchronous request/response messages of the Pact.
  /// The returned iterator needs to be freed with `pactffi_pact_sync_message_iter_delete`.
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the Pact, so it is always safe to use.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain embedded
  /// null ('\0') bytes.
  ffi.Pointer<PactSyncMessageIterator>
      pactffi_pact_handle_get_sync_message_iter(
    int pact,
  ) {
    return _pactffi_pact_handle_get_sync_message_iter(
      pact,
    );
  }

  late final _pactffi_pact_handle_get_sync_message_iterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<PactSyncMessageIterator> Function(
              PactHandle)>>('pactffi_pact_handle_get_sync_message_iter');
  late final _pactffi_pact_handle_get_sync_message_iter =
      _pactffi_pact_handle_get_sync_message_iterPtr
          .asFunction<ffi.Pointer<PactSyncMessageIterator> Function(int)>();

  /// Get an iterator over all the synchronous HTTP request/response interactions of the Pact.
  /// The returned iterator needs to be freed with `pactffi_pact_sync_http_iter_delete`.
  ///
  /// # Safety
  ///
  /// The iterator contains a copy of the Pact, so it is always safe to use.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a NULL pointer.
  ///
  /// This function may fail if any of the Rust strings contain embedded
  /// null ('\0') bytes.
  ffi.Pointer<PactSyncHttpIterator> pactffi_pact_handle_get_sync_http_iter(
    int pact,
  ) {
    return _pactffi_pact_handle_get_sync_http_iter(
      pact,
    );
  }

  late final _pactffi_pact_handle_get_sync_http_iterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<PactSyncHttpIterator> Function(
              PactHandle)>>('pactffi_pact_handle_get_sync_http_iter');
  late final _pactffi_pact_handle_get_sync_http_iter =
      _pactffi_pact_handle_get_sync_http_iterPtr
          .asFunction<ffi.Pointer<PactSyncHttpIterator> Function(int)>();

  /// Creates a new Pact Message model and returns a handle to it.
  ///
  /// * `consumer_name` - The name of the consumer for the pact.
  /// * `provider_name` - The name of the provider for the pact.
  ///
  /// Returns a new `MessagePactHandle`. The handle will need to be freed with the `pactffi_free_message_pact_handle`
  /// function to release its resources.
  int pactffi_new_message_pact(
    ffi.Pointer<ffi.Char> consumer_name,
    ffi.Pointer<ffi.Char> provider_name,
  ) {
    return _pactffi_new_message_pact(
      consumer_name,
      provider_name,
    );
  }

  late final _pactffi_new_message_pactPtr = _lookup<
      ffi.NativeFunction<
          MessagePactHandle Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_new_message_pact');
  late final _pactffi_new_message_pact = _pactffi_new_message_pactPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Creates a new Message and returns a handle to it.
  ///
  /// * `description` - The message description. It needs to be unique for each Message.
  ///
  /// Returns a new `MessageHandle`.
  int pactffi_new_message(
    int pact,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_new_message(
      pact,
      description,
    );
  }

  late final _pactffi_new_messagePtr = _lookup<
      ffi.NativeFunction<
          MessageHandle Function(MessagePactHandle,
              ffi.Pointer<ffi.Char>)>>('pactffi_new_message');
  late final _pactffi_new_message = _pactffi_new_messagePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the description for the Message.
  ///
  /// * `description` - The message description. It needs to be unique for each message.
  void pactffi_message_expects_to_receive(
    int message,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_message_expects_to_receive(
      message,
      description,
    );
  }

  late final _pactffi_message_expects_to_receivePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(MessageHandle,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_expects_to_receive');
  late final _pactffi_message_expects_to_receive =
      _pactffi_message_expects_to_receivePtr
          .asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Adds a provider state to the Interaction.
  ///
  /// * `description` - The provider state description. It needs to be unique for each message
  void pactffi_message_given(
    int message,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_message_given(
      message,
      description,
    );
  }

  late final _pactffi_message_givenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              MessageHandle, ffi.Pointer<ffi.Char>)>>('pactffi_message_given');
  late final _pactffi_message_given = _pactffi_message_givenPtr
      .asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Adds a parameter key and value to a provider state to the Message. If the provider state
  /// does not exist, a new one will be created, otherwise the parameter will be merged into the
  /// existing one. The parameter value will be parsed as JSON.
  ///
  /// # Parameters
  /// * `description` - The provider state description. It needs to be unique.
  /// * `name` - Parameter name.
  /// * `value` - Parameter value as JSON.
  void pactffi_message_given_with_param(
    int message,
    ffi.Pointer<ffi.Char> description,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_message_given_with_param(
      message,
      description,
      name,
      value,
    );
  }

  late final _pactffi_message_given_with_paramPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              MessageHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_given_with_param');
  late final _pactffi_message_given_with_param =
      _pactffi_message_given_with_paramPtr.asFunction<
          void Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Adds the contents of the Message.
  ///
  /// Accepts JSON, binary and other payload types. Binary data will be base64 encoded when serialised.
  ///
  /// Note: For text bodies (plain text, JSON or XML), you can pass in a C string (NULL terminated)
  /// and the size of the body is not required (it will be ignored). For binary bodies, you need to
  /// specify the number of bytes in the body.
  ///
  /// * `content_type` - The content type of the body. Defaults to `text/plain`, supports JSON structures with matchers and binary data.
  /// * `body` - The body contents as bytes. For text payloads (JSON, XML, etc.), a C string can be used and matching rules can be embedded in the body.
  /// * `content_type` - Expected content type (e.g. application/json, application/octet-stream)
  /// * `size` - number of bytes in the message body to read. This is not required for text bodies (JSON, XML, etc.).
  void pactffi_message_with_contents(
    int message_handle,
    ffi.Pointer<ffi.Char> content_type,
    ffi.Pointer<ffi.Uint8> body,
    int size,
  ) {
    return _pactffi_message_with_contents(
      message_handle,
      content_type,
      body,
      size,
    );
  }

  late final _pactffi_message_with_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              MessageHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('pactffi_message_with_contents');
  late final _pactffi_message_with_contents =
      _pactffi_message_with_contentsPtr.asFunction<
          void Function(
              int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Adds expected metadata to the Message
  ///
  /// * `key` - metadata key
  /// * `value` - metadata value.
  void pactffi_message_with_metadata(
    int message_handle,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_message_with_metadata(
      message_handle,
      key,
      value,
    );
  }

  late final _pactffi_message_with_metadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(MessageHandle, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_with_metadata');
  late final _pactffi_message_with_metadata =
      _pactffi_message_with_metadataPtr.asFunction<
          void Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Adds expected metadata to the Message
  ///
  /// * `key` - metadata key
  /// * `value` - metadata value, supports JSON structures with matchers and generators
  ///
  /// To include matching rules for the value, include the
  /// matching rule JSON format with the value as a single JSON document. I.e.
  ///
  /// ```c
  /// const char* value = "{\"value\": { \"ID\": \"sjhdjkshsdjh\", \"weight\": 100.5 }, \"pact:matcher:type\":\"type\"}";
  /// pactffi_message_with_metadata_v2(handle, "TagData", value);
  /// ```
  /// See [IntegrationJson.md](https://github.com/pact-foundation/pact-reference/blob/master/rust/pact_ffi/IntegrationJson.md)
  ///
  /// # Safety
  /// The key and value parameters must be valid pointers to NULL terminated strings.
  void pactffi_message_with_metadata_v2(
    int message_handle,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_message_with_metadata_v2(
      message_handle,
      key,
      value,
    );
  }

  late final _pactffi_message_with_metadata_v2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(MessageHandle, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_message_with_metadata_v2');
  late final _pactffi_message_with_metadata_v2 =
      _pactffi_message_with_metadata_v2Ptr.asFunction<
          void Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Reifies the given message
  ///
  /// Reification is the process of stripping away any matchers, and returning the original contents.
  ///
  /// # Safety
  ///
  /// The returned string needs to be deallocated with the `free_string` function.
  /// This function must only ever be called from a foreign language. Calling it from a Rust function
  /// that has a Tokio runtime in its call stack can result in a deadlock.
  ffi.Pointer<ffi.Char> pactffi_message_reify(
    int message_handle,
  ) {
    return _pactffi_message_reify(
      message_handle,
    );
  }

  late final _pactffi_message_reifyPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(MessageHandle)>>(
      'pactffi_message_reify');
  late final _pactffi_message_reify = _pactffi_message_reifyPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// External interface to write out the message pact file. This function should
  /// be called if all the consumer tests have passed. The directory to write the file to is passed
  /// as the second parameter. If a NULL pointer is passed, the current working directory is used.
  ///
  /// If overwrite is true, the file will be overwritten with the contents of the current pact.
  /// Otherwise, it will be merged with any existing pact file.
  ///
  /// Returns 0 if the pact file was successfully written. Returns a positive code if the file can
  /// not be written, or there is no mock server running on that port or the function panics.
  ///
  /// # Errors
  ///
  /// Errors are returned as positive values.
  ///
  /// | Error | Description |
  /// |-------|-------------|
  /// | 1 | The pact file was not able to be written |
  /// | 2 | The message pact for the given handle was not found |
  int pactffi_write_message_pact_file(
    int pact,
    ffi.Pointer<ffi.Char> directory,
    bool overwrite,
  ) {
    return _pactffi_write_message_pact_file(
      pact,
      directory,
      overwrite,
    );
  }

  late final _pactffi_write_message_pact_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(MessagePactHandle, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('pactffi_write_message_pact_file');
  late final _pactffi_write_message_pact_file =
      _pactffi_write_message_pact_filePtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Char>, bool)>();

  /// Sets the additional metadata on the Pact file. Common uses are to add the client library details such as the name and version
  ///
  /// * `pact` - Handle to a Pact model
  /// * `namespace` - the top level metadat key to set any key values on
  /// * `name` - the key to set
  /// * `value` - the value to set
  void pactffi_with_message_pact_metadata(
    int pact,
    ffi.Pointer<ffi.Char> namespace_,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pactffi_with_message_pact_metadata(
      pact,
      namespace_,
      name,
      value,
    );
  }

  late final _pactffi_with_message_pact_metadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              MessagePactHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_with_message_pact_metadata');
  late final _pactffi_with_message_pact_metadata =
      _pactffi_with_message_pact_metadataPtr.asFunction<
          void Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// External interface to write out the pact file. This function should
  /// be called if all the consumer tests have passed. The directory to write the file to is passed
  /// as the second parameter. If a NULL pointer is passed, the current working directory is used.
  ///
  /// If overwrite is true, the file will be overwritten with the contents of the current pact.
  /// Otherwise, it will be merged with any existing pact file.
  ///
  /// Returns 0 if the pact file was successfully written. Returns a positive code if the file can
  /// not be written or the function panics.
  ///
  /// # Safety
  ///
  /// The directory parameter must either be NULL or point to a valid NULL terminated string.
  ///
  /// # Errors
  ///
  /// Errors are returned as positive values.
  ///
  /// | Error | Description |
  /// |-------|-------------|
  /// | 1 | The function panicked. |
  /// | 2 | The pact file was not able to be written. |
  /// | 3 | The pact for the given handle was not found. |
  int pactffi_pact_handle_write_file(
    int pact,
    ffi.Pointer<ffi.Char> directory,
    bool overwrite,
  ) {
    return _pactffi_pact_handle_write_file(
      pact,
      directory,
      overwrite,
    );
  }

  late final _pactffi_pact_handle_write_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(PactHandle, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('pactffi_pact_handle_write_file');
  late final _pactffi_pact_handle_write_file =
      _pactffi_pact_handle_write_filePtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Char>, bool)>();

  /// Creates a new V4 asynchronous message and returns a handle to it.
  ///
  /// * `description` - The message description. It needs to be unique for each Message.
  ///
  /// Returns a new `MessageHandle`.
  ///
  /// Note: This function is deprecated in favour of `new_message_interaction` which returns an
  /// InteractionHandle that can be used for both HTTP and message interactions.
  int pactffi_new_async_message(
    int pact,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _pactffi_new_async_message(
      pact,
      description,
    );
  }

  late final _pactffi_new_async_messagePtr = _lookup<
      ffi.NativeFunction<
          MessageHandle Function(
              PactHandle, ffi.Pointer<ffi.Char>)>>('pactffi_new_async_message');
  late final _pactffi_new_async_message = _pactffi_new_async_messagePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Delete a Pact handle and free the resources used by it.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a positive integer value.
  ///
  /// * `1` - The handle is not valid or does not refer to a valid Pact. Could be that it was previously deleted.
  int pactffi_free_pact_handle(
    int pact,
  ) {
    return _pactffi_free_pact_handle(
      pact,
    );
  }

  late final _pactffi_free_pact_handlePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(PactHandle)>>(
          'pactffi_free_pact_handle');
  late final _pactffi_free_pact_handle =
      _pactffi_free_pact_handlePtr.asFunction<int Function(int)>();

  /// Delete a Pact handle and free the resources used by it.
  ///
  /// # Error Handling
  ///
  /// On failure, this function will return a positive integer value.
  ///
  /// * `1` - The handle is not valid or does not refer to a valid Pact. Could be that it was previously deleted.
  int pactffi_free_message_pact_handle(
    int pact,
  ) {
    return _pactffi_free_message_pact_handle(
      pact,
    );
  }

  late final _pactffi_free_message_pact_handlePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(MessagePactHandle)>>(
          'pactffi_free_message_pact_handle');
  late final _pactffi_free_message_pact_handle =
      _pactffi_free_message_pact_handlePtr.asFunction<int Function(int)>();

  /// External interface to verifier a provider
  ///
  /// * `args` - the same as the CLI interface, except newline delimited
  ///
  /// # Errors
  ///
  /// Errors are returned as non-zero numeric values.
  ///
  /// | Error | Description |
  /// |-------|-------------|
  /// | 1 | The verification process failed, see output for errors |
  /// | 2 | A null pointer was received |
  /// | 3 | The method panicked |
  /// | 4 | Invalid arguments were provided to the verification process |
  ///
  /// # Safety
  ///
  /// Exported functions are inherently unsafe. Deal.
  int pactffi_verify(
    ffi.Pointer<ffi.Char> args,
  ) {
    return _pactffi_verify(
      args,
    );
  }

  late final _pactffi_verifyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'pactffi_verify');
  late final _pactffi_verify =
      _pactffi_verifyPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get a Handle to a newly created verifier. You should call `pactffi_verifier_shutdown` when
  /// done with the verifier to free all allocated resources.
  ///
  /// By default, verification results will not be published. To enable publishing, use
  /// `pactffi_verifier_set_publish_options` to set the required values and enable it.
  ///
  /// Deprecated: This function is deprecated. Use `pactffi_verifier_new_for_application` which allows the
  /// calling application/framework name and version to be specified.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// Returns NULL on error.
  ffi.Pointer<VerifierHandle> pactffi_verifier_new() {
    return _pactffi_verifier_new();
  }

  late final _pactffi_verifier_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<VerifierHandle> Function()>>(
          'pactffi_verifier_new');
  late final _pactffi_verifier_new = _pactffi_verifier_newPtr
      .asFunction<ffi.Pointer<VerifierHandle> Function()>();

  /// Get a Handle to a newly created verifier. You should call `pactffi_verifier_shutdown` when
  /// done with the verifier to free all allocated resources.
  ///
  /// By default, verification results will not be published. To enable publishing, use
  /// `pactffi_verifier_set_publish_options` to set the required values and enable it.
  ///
  /// # Safety
  ///
  /// This function is safe.
  ///
  /// # Error Handling
  ///
  /// Returns NULL on error.
  ffi.Pointer<VerifierHandle> pactffi_verifier_new_for_application(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> version,
  ) {
    return _pactffi_verifier_new_for_application(
      name,
      version,
    );
  }

  late final _pactffi_verifier_new_for_applicationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<VerifierHandle> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_new_for_application');
  late final _pactffi_verifier_new_for_application =
      _pactffi_verifier_new_for_applicationPtr.asFunction<
          ffi.Pointer<VerifierHandle> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Shutdown the verifier and release all resources
  void pactffi_verifier_shutdown(
    ffi.Pointer<VerifierHandle> handle,
  ) {
    return _pactffi_verifier_shutdown(
      handle,
    );
  }

  late final _pactffi_verifier_shutdownPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<VerifierHandle>)>>(
      'pactffi_verifier_shutdown');
  late final _pactffi_verifier_shutdown = _pactffi_verifier_shutdownPtr
      .asFunction<void Function(ffi.Pointer<VerifierHandle>)>();

  /// Set the provider details for the Pact verifier. Passing a NULL for any field will
  /// use the default value for that field.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_set_provider_info(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> scheme,
    ffi.Pointer<ffi.Char> host,
    int port,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _pactffi_verifier_set_provider_info(
      handle,
      name,
      scheme,
      host,
      port,
      path,
    );
  }

  late final _pactffi_verifier_set_provider_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedShort,
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_set_provider_info');
  late final _pactffi_verifier_set_provider_info =
      _pactffi_verifier_set_provider_infoPtr.asFunction<
          void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>)>();

  /// Adds a new transport for the given provider. Passing a NULL for any field will
  /// use the default value for that field.
  ///
  /// For non-plugin based message interactions, set protocol to "message" and set scheme
  /// to an empty string or "https" if secure HTTP is required. Communication to the calling
  /// application will be over HTTP to the default provider hostname.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_add_provider_transport(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> protocol,
    int port,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> scheme,
  ) {
    return _pactffi_verifier_add_provider_transport(
      handle,
      protocol,
      port,
      path,
      scheme,
    );
  }

  late final _pactffi_verifier_add_provider_transportPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<VerifierHandle>,
                  ffi.Pointer<ffi.Char>,
                  ffi.UnsignedShort,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>)>>(
      'pactffi_verifier_add_provider_transport');
  late final _pactffi_verifier_add_provider_transport =
      _pactffi_verifier_add_provider_transportPtr.asFunction<
          void Function(ffi.Pointer<VerifierHandle>, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Set the filters for the Pact verifier.
  ///
  /// If `filter_description` is not empty, it needs to be as a regular expression.
  ///
  /// `filter_no_state` is a boolean value. Set it to greater than zero to turn the option on.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_set_filter_info(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> filter_description,
    ffi.Pointer<ffi.Char> filter_state,
    int filter_no_state,
  ) {
    return _pactffi_verifier_set_filter_info(
      handle,
      filter_description,
      filter_state,
      filter_no_state,
    );
  }

  late final _pactffi_verifier_set_filter_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedChar)>>('pactffi_verifier_set_filter_info');
  late final _pactffi_verifier_set_filter_info =
      _pactffi_verifier_set_filter_infoPtr.asFunction<
          void Function(ffi.Pointer<VerifierHandle>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Set the provider state URL for the Pact verifier.
  ///
  /// `teardown` is a boolean value. If teardown state change requests should be made after an
  /// interaction is validated (default is false). Set it to greater than zero to turn the
  /// option on.
  /// `body` is a boolean value. Sets if state change request data should be sent in the body
  /// (> 0, true) or as query parameters (== 0, false). Set it to greater than zero to turn the
  /// option on.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_set_provider_state(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> url,
    int teardown,
    int body,
  ) {
    return _pactffi_verifier_set_provider_state(
      handle,
      url,
      teardown,
      body,
    );
  }

  late final _pactffi_verifier_set_provider_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedChar,
              ffi.UnsignedChar)>>('pactffi_verifier_set_provider_state');
  late final _pactffi_verifier_set_provider_state =
      _pactffi_verifier_set_provider_statePtr.asFunction<
          void Function(
              ffi.Pointer<VerifierHandle>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Set the options used by the verifier when calling the provider
  ///
  /// `disable_ssl_verification` is a boolean value. Set it to greater than zero to turn the option on.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  int pactffi_verifier_set_verification_options(
    ffi.Pointer<VerifierHandle> handle,
    int disable_ssl_verification,
    int request_timeout,
  ) {
    return _pactffi_verifier_set_verification_options(
      handle,
      disable_ssl_verification,
      request_timeout,
    );
  }

  late final _pactffi_verifier_set_verification_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<VerifierHandle>, ffi.UnsignedChar,
              ffi.UnsignedLong)>>('pactffi_verifier_set_verification_options');
  late final _pactffi_verifier_set_verification_options =
      _pactffi_verifier_set_verification_optionsPtr
          .asFunction<int Function(ffi.Pointer<VerifierHandle>, int, int)>();

  /// Enables or disables coloured output using ANSI escape codes in the verifier output. By default,
  /// coloured output is enabled.
  ///
  /// `coloured_output` is a boolean value. Set it to greater than zero to turn the option on.
  ///
  /// # Safety
  ///
  /// This function is safe as long as the handle pointer points to a valid handle.
  int pactffi_verifier_set_coloured_output(
    ffi.Pointer<VerifierHandle> handle,
    int coloured_output,
  ) {
    return _pactffi_verifier_set_coloured_output(
      handle,
      coloured_output,
    );
  }

  late final _pactffi_verifier_set_coloured_outputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<VerifierHandle>,
              ffi.UnsignedChar)>>('pactffi_verifier_set_coloured_output');
  late final _pactffi_verifier_set_coloured_output =
      _pactffi_verifier_set_coloured_outputPtr
          .asFunction<int Function(ffi.Pointer<VerifierHandle>, int)>();

  /// Enables or disables if no pacts are found to verify results in an error.
  ///
  /// `is_error` is a boolean value. Set it to greater than zero to enable an error when no pacts
  /// are found to verify, and set it to zero to disable this.
  ///
  /// # Safety
  ///
  /// This function is safe as long as the handle pointer points to a valid handle.
  int pactffi_verifier_set_no_pacts_is_error(
    ffi.Pointer<VerifierHandle> handle,
    int is_error,
  ) {
    return _pactffi_verifier_set_no_pacts_is_error(
      handle,
      is_error,
    );
  }

  late final _pactffi_verifier_set_no_pacts_is_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<VerifierHandle>,
              ffi.UnsignedChar)>>('pactffi_verifier_set_no_pacts_is_error');
  late final _pactffi_verifier_set_no_pacts_is_error =
      _pactffi_verifier_set_no_pacts_is_errorPtr
          .asFunction<int Function(ffi.Pointer<VerifierHandle>, int)>();

  /// Set the options used when publishing verification results to the Pact Broker. By default,
  /// verification results will not be published unless this function is called.
  ///
  /// # Args
  ///
  /// - `handle` - The pact verifier handle to update
  /// - `provider_version` - Version of the provider to publish
  /// - `build_url` - URL to the build which ran the verification [OPTIONAL]
  /// - `provider_tags` - Collection of tags for the provider [OPTIONAL]
  /// - `provider_tags_len` - Number of provider tags supplied [OPTIONAL]
  /// - `provider_branch` - Name of the branch used for verification [OPTIONAL]
  ///
  /// For optional args, a NULL pointer can be used.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  int pactffi_verifier_set_publish_options(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> provider_version,
    ffi.Pointer<ffi.Char> build_url,
    ffi.Pointer<ffi.Pointer<ffi.Char>> provider_tags,
    int provider_tags_len,
    ffi.Pointer<ffi.Char> provider_branch,
  ) {
    return _pactffi_verifier_set_publish_options(
      handle,
      provider_version,
      build_url,
      provider_tags,
      provider_tags_len,
      provider_branch,
    );
  }

  late final _pactffi_verifier_set_publish_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.UnsignedShort,
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_set_publish_options');
  late final _pactffi_verifier_set_publish_options =
      _pactffi_verifier_set_publish_optionsPtr.asFunction<
          int Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
              ffi.Pointer<ffi.Char>)>();

  /// Set the consumer filters for the Pact verifier.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_set_consumer_filters(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Pointer<ffi.Char>> consumer_filters,
    int consumer_filters_len,
  ) {
    return _pactffi_verifier_set_consumer_filters(
      handle,
      consumer_filters,
      consumer_filters_len,
    );
  }

  late final _pactffi_verifier_set_consumer_filtersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.UnsignedShort)>>('pactffi_verifier_set_consumer_filters');
  late final _pactffi_verifier_set_consumer_filters =
      _pactffi_verifier_set_consumer_filtersPtr.asFunction<
          void Function(ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// Adds a custom header to be added to the requests made to the provider.
  ///
  /// # Safety
  ///
  /// The header name and value must point to a valid NULL terminated string and must contain
  /// valid UTF-8.
  void pactffi_verifier_add_custom_header(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> header_name,
    ffi.Pointer<ffi.Char> header_value,
  ) {
    return _pactffi_verifier_add_custom_header(
      handle,
      header_name,
      header_value,
    );
  }

  late final _pactffi_verifier_add_custom_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VerifierHandle>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_add_custom_header');
  late final _pactffi_verifier_add_custom_header =
      _pactffi_verifier_add_custom_headerPtr.asFunction<
          void Function(ffi.Pointer<VerifierHandle>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Adds a Pact file as a source to verify.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_add_file_source(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> file,
  ) {
    return _pactffi_verifier_add_file_source(
      handle,
      file,
    );
  }

  late final _pactffi_verifier_add_file_sourcePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_add_file_source');
  late final _pactffi_verifier_add_file_source =
      _pactffi_verifier_add_file_sourcePtr.asFunction<
          void Function(ffi.Pointer<VerifierHandle>, ffi.Pointer<ffi.Char>)>();

  /// Adds a Pact directory as a source to verify. All pacts from the directory that match the
  /// provider name will be verified.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_add_directory_source(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> directory,
  ) {
    return _pactffi_verifier_add_directory_source(
      handle,
      directory,
    );
  }

  late final _pactffi_verifier_add_directory_sourcePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_add_directory_source');
  late final _pactffi_verifier_add_directory_source =
      _pactffi_verifier_add_directory_sourcePtr.asFunction<
          void Function(ffi.Pointer<VerifierHandle>, ffi.Pointer<ffi.Char>)>();

  /// Adds a URL as a source to verify. The Pact file will be fetched from the URL.
  ///
  /// If a username and password is given, then basic authentication will be used when fetching
  /// the pact file. If a token is provided, then bearer token authentication will be used.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_url_source(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
    ffi.Pointer<ffi.Char> token,
  ) {
    return _pactffi_verifier_url_source(
      handle,
      url,
      username,
      password,
      token,
    );
  }

  late final _pactffi_verifier_url_sourcePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_url_source');
  late final _pactffi_verifier_url_source =
      _pactffi_verifier_url_sourcePtr.asFunction<
          void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Adds a Pact broker as a source to verify. This will fetch all the pact files from the broker
  /// that match the provider name.
  ///
  /// If a username and password is given, then basic authentication will be used when fetching
  /// the pact file. If a token is provided, then bearer token authentication will be used.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  void pactffi_verifier_broker_source(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
    ffi.Pointer<ffi.Char> token,
  ) {
    return _pactffi_verifier_broker_source(
      handle,
      url,
      username,
      password,
      token,
    );
  }

  late final _pactffi_verifier_broker_sourcePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_broker_source');
  late final _pactffi_verifier_broker_source =
      _pactffi_verifier_broker_sourcePtr.asFunction<
          void Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Adds a Pact broker as a source to verify. This will fetch all the pact files from the broker
  /// that match the provider name and the consumer version selectors
  /// (See `https://docs.pact.io/pact_broker/advanced_topics/consumer_version_selectors/`).
  ///
  /// The consumer version selectors must be passed in in JSON format.
  ///
  /// `enable_pending` is a boolean value. Set it to greater than zero to turn the option on.
  ///
  /// If the `include_wip_pacts_since` option is provided, it needs to be a date formatted in
  /// ISO format (YYYY-MM-DD).
  ///
  /// If a username and password is given, then basic authentication will be used when fetching
  /// the pact file. If a token is provided, then bearer token authentication will be used.
  ///
  /// This function will return zero unless any of the consumer version selectors are not valid
  /// JSON, in which case, it will return -1.
  ///
  /// # Safety
  ///
  /// All string fields must contain valid UTF-8. Invalid UTF-8
  /// will be replaced with U+FFFD REPLACEMENT CHARACTER.
  int pactffi_verifier_broker_source_with_selectors(
    ffi.Pointer<VerifierHandle> handle,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
    ffi.Pointer<ffi.Char> token,
    int enable_pending,
    ffi.Pointer<ffi.Char> include_wip_pacts_since,
    ffi.Pointer<ffi.Pointer<ffi.Char>> provider_tags,
    int provider_tags_len,
    ffi.Pointer<ffi.Char> provider_branch,
    ffi.Pointer<ffi.Pointer<ffi.Char>> consumer_version_selectors,
    int consumer_version_selectors_len,
    ffi.Pointer<ffi.Pointer<ffi.Char>> consumer_version_tags,
    int consumer_version_tags_len,
  ) {
    return _pactffi_verifier_broker_source_with_selectors(
      handle,
      url,
      username,
      password,
      token,
      enable_pending,
      include_wip_pacts_since,
      provider_tags,
      provider_tags_len,
      provider_branch,
      consumer_version_selectors,
      consumer_version_selectors_len,
      consumer_version_tags,
      consumer_version_tags_len,
    );
  }

  late final _pactffi_verifier_broker_source_with_selectorsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<VerifierHandle>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.UnsignedChar,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.UnsignedShort,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.UnsignedShort,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.UnsignedShort)>>(
      'pactffi_verifier_broker_source_with_selectors');
  late final _pactffi_verifier_broker_source_with_selectors =
      _pactffi_verifier_broker_source_with_selectorsPtr.asFunction<
          int Function(
              ffi.Pointer<VerifierHandle>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int)>();

  /// Runs the verification.
  ///
  /// # Error Handling
  ///
  /// Errors will be reported with a non-zero return value.
  int pactffi_verifier_execute(
    ffi.Pointer<VerifierHandle> handle,
  ) {
    return _pactffi_verifier_execute(
      handle,
    );
  }

  late final _pactffi_verifier_executePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<VerifierHandle>)>>(
      'pactffi_verifier_execute');
  late final _pactffi_verifier_execute = _pactffi_verifier_executePtr
      .asFunction<int Function(ffi.Pointer<VerifierHandle>)>();

  /// External interface to retrieve the options and arguments available when calling the CLI interface,
  /// returning them as a JSON string.
  ///
  /// The purpose is to then be able to use in other languages which wrap the FFI library, to implement
  /// the same CLI functionality automatically without manual maintenance of arguments, help descriptions
  /// etc.
  ///
  /// # Example structure
  /// ```json
  /// {
  /// "options": [
  /// {
  /// "long": "scheme",
  /// "help": "Provider URI scheme (defaults to http)",
  /// "possible_values": [
  /// "http",
  /// "https"
  /// ],
  /// "default_value": "http"
  /// "multiple": false,
  /// },
  /// {
  /// "long": "file",
  /// "short": "f",
  /// "help": "Pact file to verify (can be repeated)",
  /// "multiple": true
  /// },
  /// {
  /// "long": "user",
  /// "help": "Username to use when fetching pacts from URLS",
  /// "multiple": false,
  /// "env": "PACT_BROKER_USERNAME"
  /// }
  /// ],
  /// "flags": [
  /// {
  /// "long": "disable-ssl-verification",
  /// "help": "Disables validation of SSL certificates",
  /// "multiple": false
  /// }
  /// ]
  /// }
  /// ```
  ///
  /// # Safety
  ///
  /// Exported functions are inherently unsafe.
  ffi.Pointer<ffi.Char> pactffi_verifier_cli_args() {
    return _pactffi_verifier_cli_args();
  }

  late final _pactffi_verifier_cli_argsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pactffi_verifier_cli_args');
  late final _pactffi_verifier_cli_args = _pactffi_verifier_cli_argsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Extracts the logs for the verification run. This needs the memory buffer log sink to be
  /// setup before the verification is executed. The returned string will need to be freed with
  /// the `free_string` function call to avoid leaking memory.
  ///
  /// Will return a NULL pointer if the logs for the verification can not be retrieved.
  ffi.Pointer<ffi.Char> pactffi_verifier_logs(
    ffi.Pointer<VerifierHandle> handle,
  ) {
    return _pactffi_verifier_logs(
      handle,
    );
  }

  late final _pactffi_verifier_logsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<VerifierHandle>)>>('pactffi_verifier_logs');
  late final _pactffi_verifier_logs = _pactffi_verifier_logsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<VerifierHandle>)>();

  /// Extracts the logs for the verification run for the provider name. This needs the memory
  /// buffer log sink to be setup before the verification is executed. The returned string will
  /// need to be freed with the `free_string` function call to avoid leaking memory.
  ///
  /// Will return a NULL pointer if the logs for the verification can not be retrieved.
  ffi.Pointer<ffi.Char> pactffi_verifier_logs_for_provider(
    ffi.Pointer<ffi.Char> provider_name,
  ) {
    return _pactffi_verifier_logs_for_provider(
      provider_name,
    );
  }

  late final _pactffi_verifier_logs_for_providerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('pactffi_verifier_logs_for_provider');
  late final _pactffi_verifier_logs_for_provider =
      _pactffi_verifier_logs_for_providerPtr
          .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Extracts the standard output for the verification run. The returned string will need to be
  /// freed with the `free_string` function call to avoid leaking memory.
  ///
  /// * `strip_ansi` - This parameter controls ANSI escape codes. Setting it to a non-zero value
  /// will cause the ANSI control codes to be stripped from the output.
  ///
  /// Will return a NULL pointer if the handle is invalid.
  ffi.Pointer<ffi.Char> pactffi_verifier_output(
    ffi.Pointer<VerifierHandle> handle,
    int strip_ansi,
  ) {
    return _pactffi_verifier_output(
      handle,
      strip_ansi,
    );
  }

  late final _pactffi_verifier_outputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<VerifierHandle>,
              ffi.UnsignedChar)>>('pactffi_verifier_output');
  late final _pactffi_verifier_output = _pactffi_verifier_outputPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<VerifierHandle>, int)>();

  /// Extracts the verification result as a JSON document. The returned string will need to be
  /// freed with the `free_string` function call to avoid leaking memory.
  ///
  /// Will return a NULL pointer if the handle is invalid.
  ffi.Pointer<ffi.Char> pactffi_verifier_json(
    ffi.Pointer<VerifierHandle> handle,
  ) {
    return _pactffi_verifier_json(
      handle,
    );
  }

  late final _pactffi_verifier_jsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<VerifierHandle>)>>('pactffi_verifier_json');
  late final _pactffi_verifier_json = _pactffi_verifier_jsonPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<VerifierHandle>)>();

  /// Add a plugin to be used by the test. The plugin needs to be installed correctly for this
  /// function to work.
  ///
  /// * `plugin_name` is the name of the plugin to load.
  /// * `plugin_version` is the version of the plugin to load. It is optional, and can be NULL.
  ///
  /// Returns zero on success, and a positive integer value on failure.
  ///
  /// Note that plugins run as separate processes, so will need to be cleaned up afterwards by
  /// calling `pactffi_cleanup_plugins` otherwise you will have plugin processes left running.
  ///
  /// # Safety
  ///
  /// `plugin_name` must be a valid pointer to a NULL terminated string. `plugin_version` may be null,
  /// and if not NULL must also be a valid pointer to a NULL terminated string. Invalid
  /// pointers will result in undefined behaviour.
  ///
  /// # Errors
  ///
  /// * `1` - A general panic was caught.
  /// * `2` - Failed to load the plugin.
  /// * `3` - Pact Handle is not valid.
  ///
  /// When an error errors, LAST_ERROR will contain the error message.
  int pactffi_using_plugin(
    int pact,
    ffi.Pointer<ffi.Char> plugin_name,
    ffi.Pointer<ffi.Char> plugin_version,
  ) {
    return _pactffi_using_plugin(
      pact,
      plugin_name,
      plugin_version,
    );
  }

  late final _pactffi_using_pluginPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(PactHandle, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_using_plugin');
  late final _pactffi_using_plugin = _pactffi_using_pluginPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Decrement the access count on any plugins that are loaded for the Pact. This will shutdown
  /// any plugins that are no longer required (access count is zero).
  void pactffi_cleanup_plugins(
    int pact,
  ) {
    return _pactffi_cleanup_plugins(
      pact,
    );
  }

  late final _pactffi_cleanup_pluginsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(PactHandle)>>(
          'pactffi_cleanup_plugins');
  late final _pactffi_cleanup_plugins =
      _pactffi_cleanup_pluginsPtr.asFunction<void Function(int)>();

  /// Setup the interaction part using a plugin. The contents is a JSON string that will be passed on to
  /// the plugin to configure the interaction part. Refer to the plugin documentation on the format
  /// of the JSON contents.
  ///
  /// Returns zero on success, and a positive integer value on failure.
  ///
  /// * `interaction` - Handle to the interaction to configure.
  /// * `part` - The part of the interaction to configure (request or response). It is ignored for messages.
  /// * `content_type` - NULL terminated C string of the content type of the part.
  /// * `contents` - NULL terminated C string of the JSON contents that gets passed to the plugin.
  ///
  /// # Safety
  ///
  /// `content_type` and `contents` must be a valid pointers to NULL terminated strings. Invalid
  /// pointers will result in undefined behaviour.
  ///
  /// # Errors
  ///
  /// * `1` - A general panic was caught.
  /// * `2` - The mock server has already been started.
  /// * `3` - The interaction handle is invalid.
  /// * `4` - The content type is not valid.
  /// * `5` - The contents JSON is not valid JSON.
  /// * `6` - The plugin returned an error.
  ///
  /// When an error errors, LAST_ERROR will contain the error message.
  int pactffi_interaction_contents(
    DartInteractionHandle interaction,
    InteractionPart part,
    ffi.Pointer<ffi.Char> content_type,
    ffi.Pointer<ffi.Char> contents,
  ) {
    return _pactffi_interaction_contents(
      interaction,
      part.value,
      content_type,
      contents,
    );
  }

  late final _pactffi_interaction_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              InteractionHandle,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pactffi_interaction_contents');
  late final _pactffi_interaction_contents =
      _pactffi_interaction_contentsPtr.asFunction<
          int Function(
              int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Determines if the string value matches the given matching rule. If the value matches OK,
  /// will return a NULL pointer. If the value does not match, will return a error message as
  /// a NULL terminated string. The error message pointer will need to be deleted with the
  /// `pactffi_string_delete` function once it is no longer required.
  ///
  /// * matching_rule - pointer to a matching rule
  /// * expected_value - value we expect to get as a NULL terminated string
  /// * actual_value - value to match as a NULL terminated string
  /// * cascaded - if the matching rule has been cascaded from a parent. 0 == false, 1 == true
  ///
  /// # Safety
  ///
  /// The matching rule pointer must be a valid pointer, and the value parameters must be
  /// valid pointers to a NULL terminated strings.
  ffi.Pointer<ffi.Char> pactffi_matches_string_value(
    ffi.Pointer<MatchingRule> matching_rule,
    ffi.Pointer<ffi.Char> expected_value,
    ffi.Pointer<ffi.Char> actual_value,
    int cascaded,
  ) {
    return _pactffi_matches_string_value(
      matching_rule,
      expected_value,
      actual_value,
      cascaded,
    );
  }

  late final _pactffi_matches_string_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint8)>>('pactffi_matches_string_value');
  late final _pactffi_matches_string_value =
      _pactffi_matches_string_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRule>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Determines if the unsigned integer value matches the given matching rule. If the value matches OK,
  /// will return a NULL pointer. If the value does not match, will return a error message as
  /// a NULL terminated string. The error message pointer will need to be deleted with the
  /// `pactffi_string_delete` function once it is no longer required.
  ///
  /// * matching_rule - pointer to a matching rule
  /// * expected_value - value we expect to get
  /// * actual_value - value to match
  /// * cascaded - if the matching rule has been cascaded from a parent. 0 == false, 1 == true
  ///
  /// # Safety
  ///
  /// The matching rule pointer must be a valid pointer.
  ffi.Pointer<ffi.Char> pactffi_matches_u64_value(
    ffi.Pointer<MatchingRule> matching_rule,
    int expected_value,
    int actual_value,
    int cascaded,
  ) {
    return _pactffi_matches_u64_value(
      matching_rule,
      expected_value,
      actual_value,
      cascaded,
    );
  }

  late final _pactffi_matches_u64_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRule>, ffi.Uint64,
              ffi.Uint64, ffi.Uint8)>>('pactffi_matches_u64_value');
  late final _pactffi_matches_u64_value =
      _pactffi_matches_u64_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>, int, int, int)>();

  /// Determines if the signed integer value matches the given matching rule. If the value matches OK,
  /// will return a NULL pointer. If the value does not match, will return a error message as
  /// a NULL terminated string. The error message pointer will need to be deleted with the
  /// `pactffi_string_delete` function once it is no longer required.
  ///
  /// * matching_rule - pointer to a matching rule
  /// * expected_value - value we expect to get
  /// * actual_value - value to match
  /// * cascaded - if the matching rule has been cascaded from a parent. 0 == false, 1 == true
  ///
  /// # Safety
  ///
  /// The matching rule pointer must be a valid pointer.
  ffi.Pointer<ffi.Char> pactffi_matches_i64_value(
    ffi.Pointer<MatchingRule> matching_rule,
    int expected_value,
    int actual_value,
    int cascaded,
  ) {
    return _pactffi_matches_i64_value(
      matching_rule,
      expected_value,
      actual_value,
      cascaded,
    );
  }

  late final _pactffi_matches_i64_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRule>, ffi.Int64,
              ffi.Int64, ffi.Uint8)>>('pactffi_matches_i64_value');
  late final _pactffi_matches_i64_value =
      _pactffi_matches_i64_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>, int, int, int)>();

  /// Determines if the floating point value matches the given matching rule. If the value matches OK,
  /// will return a NULL pointer. If the value does not match, will return a error message as
  /// a NULL terminated string. The error message pointer will need to be deleted with the
  /// `pactffi_string_delete` function once it is no longer required.
  ///
  /// * matching_rule - pointer to a matching rule
  /// * expected_value - value we expect to get
  /// * actual_value - value to match
  /// * cascaded - if the matching rule has been cascaded from a parent. 0 == false, 1 == true
  ///
  /// # Safety
  ///
  /// The matching rule pointer must be a valid pointer.
  ffi.Pointer<ffi.Char> pactffi_matches_f64_value(
    ffi.Pointer<MatchingRule> matching_rule,
    double expected_value,
    double actual_value,
    int cascaded,
  ) {
    return _pactffi_matches_f64_value(
      matching_rule,
      expected_value,
      actual_value,
      cascaded,
    );
  }

  late final _pactffi_matches_f64_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRule>, ffi.Double,
              ffi.Double, ffi.Uint8)>>('pactffi_matches_f64_value');
  late final _pactffi_matches_f64_value =
      _pactffi_matches_f64_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>, double, double, int)>();

  /// Determines if the boolean value matches the given matching rule. If the value matches OK,
  /// will return a NULL pointer. If the value does not match, will return a error message as
  /// a NULL terminated string. The error message pointer will need to be deleted with the
  /// `pactffi_string_delete` function once it is no longer required.
  ///
  /// * matching_rule - pointer to a matching rule
  /// * expected_value - value we expect to get, 0 == false and 1 == true
  /// * actual_value - value to match, 0 == false and 1 == true
  /// * cascaded - if the matching rule has been cascaded from a parent. 0 == false, 1 == true
  ///
  /// # Safety
  ///
  /// The matching rule pointer must be a valid pointer.
  ffi.Pointer<ffi.Char> pactffi_matches_bool_value(
    ffi.Pointer<MatchingRule> matching_rule,
    int expected_value,
    int actual_value,
    int cascaded,
  ) {
    return _pactffi_matches_bool_value(
      matching_rule,
      expected_value,
      actual_value,
      cascaded,
    );
  }

  late final _pactffi_matches_bool_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRule>, ffi.Uint8,
              ffi.Uint8, ffi.Uint8)>>('pactffi_matches_bool_value');
  late final _pactffi_matches_bool_value =
      _pactffi_matches_bool_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>, int, int, int)>();

  /// Determines if the binary value matches the given matching rule. If the value matches OK,
  /// will return a NULL pointer. If the value does not match, will return a error message as
  /// a NULL terminated string. The error message pointer will need to be deleted with the
  /// `pactffi_string_delete` function once it is no longer required.
  ///
  /// * matching_rule - pointer to a matching rule
  /// * expected_value - value we expect to get
  /// * expected_value_len - length of the expected value bytes
  /// * actual_value - value to match
  /// * actual_value_len - length of the actual value bytes
  /// * cascaded - if the matching rule has been cascaded from a parent. 0 == false, 1 == true
  ///
  /// # Safety
  ///
  /// The matching rule, expected value and actual value pointers must be a valid pointers.
  /// expected_value_len and actual_value_len must contain the number of bytes that the value
  /// pointers point to. Passing invalid lengths can lead to undefined behaviour.
  ffi.Pointer<ffi.Char> pactffi_matches_binary_value(
    ffi.Pointer<MatchingRule> matching_rule,
    ffi.Pointer<ffi.UnsignedChar> expected_value,
    int expected_value_len,
    ffi.Pointer<ffi.UnsignedChar> actual_value,
    int actual_value_len,
    int cascaded,
  ) {
    return _pactffi_matches_binary_value(
      matching_rule,
      expected_value,
      expected_value_len,
      actual_value,
      actual_value_len,
      cascaded,
    );
  }

  late final _pactffi_matches_binary_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UintPtr,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UintPtr,
              ffi.Uint8)>>('pactffi_matches_binary_value');
  late final _pactffi_matches_binary_value =
      _pactffi_matches_binary_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              int)>();

  /// Determines if the JSON value matches the given matching rule. If the value matches OK,
  /// will return a NULL pointer. If the value does not match, will return a error message as
  /// a NULL terminated string. The error message pointer will need to be deleted with the
  /// `pactffi_string_delete` function once it is no longer required.
  ///
  /// * matching_rule - pointer to a matching rule
  /// * expected_value - value we expect to get as a NULL terminated string
  /// * actual_value - value to match as a NULL terminated string
  /// * cascaded - if the matching rule has been cascaded from a parent. 0 == false, 1 == true
  ///
  /// # Safety
  ///
  /// The matching rule pointer must be a valid pointer, and the value parameters must be
  /// valid pointers to a NULL terminated strings.
  ffi.Pointer<ffi.Char> pactffi_matches_json_value(
    ffi.Pointer<MatchingRule> matching_rule,
    ffi.Pointer<ffi.Char> expected_value,
    ffi.Pointer<ffi.Char> actual_value,
    int cascaded,
  ) {
    return _pactffi_matches_json_value(
      matching_rule,
      expected_value,
      actual_value,
      cascaded,
    );
  }

  late final _pactffi_matches_json_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<MatchingRule>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint8)>>('pactffi_matches_json_value');
  late final _pactffi_matches_json_value =
      _pactffi_matches_json_valuePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<MatchingRule>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();
}

typedef __builtin_va_list = ffi.Pointer<ffi.Char>;
typedef __gnuc_va_list = __builtin_va_list;
typedef va_list = __builtin_va_list;
typedef int_least8_t = ffi.Int8;
typedef Dartint_least8_t = int;
typedef int_least16_t = ffi.Int16;
typedef Dartint_least16_t = int;
typedef int_least32_t = ffi.Int32;
typedef Dartint_least32_t = int;
typedef int_least64_t = ffi.Int64;
typedef Dartint_least64_t = int;
typedef uint_least8_t = ffi.Uint8;
typedef Dartuint_least8_t = int;
typedef uint_least16_t = ffi.Uint16;
typedef Dartuint_least16_t = int;
typedef uint_least32_t = ffi.Uint32;
typedef Dartuint_least32_t = int;
typedef uint_least64_t = ffi.Uint64;
typedef Dartuint_least64_t = int;
typedef int_fast8_t = ffi.Int8;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Int16;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Int32;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.Int64;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.Uint8;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.Uint16;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.Uint32;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.Uint64;
typedef Dartuint_fast64_t = int;
typedef __int8_t = ffi.SignedChar;
typedef Dart__int8_t = int;
typedef __uint8_t = ffi.UnsignedChar;
typedef Dart__uint8_t = int;
typedef __int16_t = ffi.Short;
typedef Dart__int16_t = int;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;
typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;
typedef __darwin_intptr_t = ffi.Long;
typedef Dart__darwin_intptr_t = int;
typedef __darwin_natural_t = ffi.UnsignedInt;
typedef Dart__darwin_natural_t = int;
typedef __darwin_ct_rune_t = ffi.Int;
typedef Dart__darwin_ct_rune_t = int;

final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

typedef __darwin_mbstate_t = __mbstate_t;
typedef __darwin_ptrdiff_t = ffi.Long;
typedef Dart__darwin_ptrdiff_t = int;
typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;
typedef __darwin_va_list = __builtin_va_list;
typedef __darwin_wchar_t = ffi.Int;
typedef Dart__darwin_wchar_t = int;
typedef __darwin_rune_t = __darwin_wchar_t;
typedef __darwin_wint_t = ffi.Int;
typedef Dart__darwin_wint_t = int;
typedef __darwin_clock_t = ffi.UnsignedLong;
typedef Dart__darwin_clock_t = int;
typedef __darwin_socklen_t = __uint32_t;
typedef __darwin_ssize_t = ffi.Long;
typedef Dart__darwin_ssize_t = int;
typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_blkcnt_t = __int64_t;
typedef __darwin_blksize_t = __int32_t;
typedef __darwin_dev_t = __int32_t;
typedef __darwin_fsblkcnt_t = ffi.UnsignedInt;
typedef Dart__darwin_fsblkcnt_t = int;
typedef __darwin_fsfilcnt_t = ffi.UnsignedInt;
typedef Dart__darwin_fsfilcnt_t = int;
typedef __darwin_gid_t = __uint32_t;
typedef __darwin_id_t = __uint32_t;
typedef __darwin_ino64_t = __uint64_t;
typedef __darwin_ino_t = __darwin_ino64_t;
typedef __darwin_mach_port_name_t = __darwin_natural_t;
typedef __darwin_mach_port_t = __darwin_mach_port_name_t;
typedef __darwin_mode_t = __uint16_t;
typedef __darwin_off_t = __int64_t;
typedef __darwin_pid_t = __int32_t;
typedef __darwin_sigset_t = __uint32_t;
typedef __darwin_suseconds_t = __int32_t;
typedef __darwin_uid_t = __uint32_t;
typedef __darwin_useconds_t = __uint32_t;

final class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;
typedef __darwin_pthread_cond_t = _opaque_pthread_cond_t;
typedef __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
typedef __darwin_pthread_key_t = ffi.UnsignedLong;
typedef Dart__darwin_pthread_key_t = int;
typedef __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
typedef __darwin_pthread_once_t = _opaque_pthread_once_t;
typedef __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
typedef __darwin_pthread_t = ffi.Pointer<_opaque_pthread_t>;
typedef intmax_t = ffi.Long;
typedef Dartintmax_t = int;
typedef uintmax_t = ffi.UnsignedLong;
typedef Dartuintmax_t = int;
typedef __darwin_nl_item = ffi.Int;
typedef Dart__darwin_nl_item = int;
typedef __darwin_wctrans_t = ffi.Int;
typedef Dart__darwin_wctrans_t = int;
typedef __darwin_wctype_t = __uint32_t;

enum idtype_t {
  P_ALL(0),
  P_PID(1),
  P_PGID(2);

  final int value;
  const idtype_t(this.value);

  static idtype_t fromValue(int value) => switch (value) {
        0 => P_ALL,
        1 => P_PID,
        2 => P_PGID,
        _ => throw ArgumentError('Unknown value for idtype_t: $value'),
      };
}

typedef pid_t = __darwin_pid_t;
typedef id_t = __darwin_id_t;
typedef sig_atomic_t = ffi.Int;
typedef Dartsig_atomic_t = int;
typedef u_int8_t = ffi.UnsignedChar;
typedef Dartu_int8_t = int;
typedef u_int16_t = ffi.UnsignedShort;
typedef Dartu_int16_t = int;
typedef u_int32_t = ffi.UnsignedInt;
typedef Dartu_int32_t = int;
typedef u_int64_t = ffi.UnsignedLongLong;
typedef Dartu_int64_t = int;
typedef register_t = ffi.Int64;
typedef Dartregister_t = int;
typedef user_addr_t = u_int64_t;
typedef user_size_t = u_int64_t;
typedef user_ssize_t = ffi.Int64;
typedef Dartuser_ssize_t = int;
typedef user_long_t = ffi.Int64;
typedef Dartuser_long_t = int;
typedef user_ulong_t = u_int64_t;
typedef user_time_t = ffi.Int64;
typedef Dartuser_time_t = int;
typedef user_off_t = ffi.Int64;
typedef Dartuser_off_t = int;
typedef syscall_arg_t = u_int64_t;

final class __darwin_arm_exception_state extends ffi.Struct {
  @__uint32_t()
  external int __exception;

  @__uint32_t()
  external int __fsr;

  @__uint32_t()
  external int __far;
}

final class __darwin_arm_exception_state64 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint32_t()
  external int __esr;

  @__uint32_t()
  external int __exception;
}

final class __darwin_arm_exception_state64_v2 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint64_t()
  external int __esr;
}

final class __darwin_arm_thread_state extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __sp;

  @__uint32_t()
  external int __lr;

  @__uint32_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  @__uint64_t()
  external int __fp;

  @__uint64_t()
  external int __lr;

  @__uint64_t()
  external int __sp;

  @__uint64_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;

  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __darwin_arm_sme_state extends ffi.Struct {
  @__uint64_t()
  external int __svcr;

  @__uint64_t()
  external int __tpidr2_el0;

  @__uint16_t()
  external int __svl_b;
}

final class __darwin_arm_sve_z_state extends ffi.Struct {
  @ffi.Array.multi([16, 256])
  external ffi.Array<ffi.Array<ffi.Char>> __z;
}

final class __darwin_arm_sve_p_state extends ffi.Struct {
  @ffi.Array.multi([16, 32])
  external ffi.Array<ffi.Array<ffi.Char>> __p;
}

final class __darwin_arm_sme_za_state extends ffi.Struct {
  @ffi.Array.multi([4096])
  external ffi.Array<ffi.Char> __za;
}

final class __darwin_arm_sme2_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> __zt0;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

typedef mcontext_t = ffi.Pointer<__darwin_mcontext64>;
typedef pthread_attr_t = __darwin_pthread_attr_t;

final class __darwin_sigaltstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @__darwin_size_t()
  external int ss_size;

  @ffi.Int()
  external int ss_flags;
}

typedef stack_t = __darwin_sigaltstack;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  @__darwin_sigset_t()
  external int uc_sigmask;

  external __darwin_sigaltstack uc_stack;

  external ffi.Pointer<__darwin_ucontext> uc_link;

  @__darwin_size_t()
  external int uc_mcsize;

  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef ucontext_t = __darwin_ucontext;
typedef sigset_t = __darwin_sigset_t;
typedef uid_t = __darwin_uid_t;

final class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  @ffi.Int()
  external int sigev_notify;

  @ffi.Int()
  external int sigev_signo;

  external sigval sigev_value;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

final class __siginfo extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @pid_t()
  external int si_pid;

  @uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  external ffi.Pointer<ffi.Void> si_addr;

  external sigval si_value;

  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef siginfo_t = __siginfo;

final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

final class __sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u$1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

final class sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u$1;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

typedef sig_tFunction = ffi.Void Function(ffi.Int);
typedef Dartsig_tFunction = void Function(int);
typedef sig_t = ffi.Pointer<ffi.NativeFunction<sig_tFunction>>;

final class sigvec extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  @ffi.Int()
  external int sv_mask;

  @ffi.Int()
  external int sv_flags;
}

final class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

final class timeval extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef rlim_t = __uint64_t;

final class rusage extends ffi.Struct {
  external timeval ru_utime;

  external timeval ru_stime;

  @ffi.Long()
  external int ru_maxrss;

  @ffi.Long()
  external int ru_ixrss;

  @ffi.Long()
  external int ru_idrss;

  @ffi.Long()
  external int ru_isrss;

  @ffi.Long()
  external int ru_minflt;

  @ffi.Long()
  external int ru_majflt;

  @ffi.Long()
  external int ru_nswap;

  @ffi.Long()
  external int ru_inblock;

  @ffi.Long()
  external int ru_oublock;

  @ffi.Long()
  external int ru_msgsnd;

  @ffi.Long()
  external int ru_msgrcv;

  @ffi.Long()
  external int ru_nsignals;

  @ffi.Long()
  external int ru_nvcsw;

  @ffi.Long()
  external int ru_nivcsw;
}

typedef rusage_info_t = ffi.Pointer<ffi.Void>;

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Uint64()
  external int ri_neural_footprint;

  @ffi.Uint64()
  external int ri_lifetime_max_neural_footprint;

  @ffi.Uint64()
  external int ri_interval_max_neural_footprint;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

typedef rusage_info_current = rusage_info_v6;

final class rlimit extends ffi.Struct {
  @rlim_t()
  external int rlim_cur;

  @rlim_t()
  external int rlim_max;
}

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

final class wait$1 extends ffi.Opaque {}

typedef ct_rune_t = __darwin_ct_rune_t;
typedef rune_t = __darwin_rune_t;

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

typedef malloc_type_id_t = ffi.UnsignedLongLong;
typedef Dartmalloc_type_id_t = int;

final class _malloc_zone_t extends ffi.Opaque {}

typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef mode_t = __darwin_mode_t;

/// The type of value detected after parsing the expression
enum ExpressionValueType {
  /// If the type is unknown
  ExpressionValueType_Unknown(0),

  /// String type
  ExpressionValueType_String(1),

  /// Numeric type
  ExpressionValueType_Number(2),

  /// Integer numeric type (no significant figures after the decimal point)
  ExpressionValueType_Integer(3),

  /// Decimal numeric type (at least one significant figure after the decimal point)
  ExpressionValueType_Decimal(4),

  /// Boolean type
  ExpressionValueType_Boolean(5);

  final int value;
  const ExpressionValueType(this.value);

  static ExpressionValueType fromValue(int value) => switch (value) {
        0 => ExpressionValueType_Unknown,
        1 => ExpressionValueType_String,
        2 => ExpressionValueType_Number,
        3 => ExpressionValueType_Integer,
        4 => ExpressionValueType_Decimal,
        5 => ExpressionValueType_Boolean,
        _ =>
          throw ArgumentError('Unknown value for ExpressionValueType: $value'),
      };
}

/// Enum defining the categories that generators can be applied to
enum GeneratorCategory {
  /// Request Method
  GeneratorCategory_METHOD(0),

  /// Request Path
  GeneratorCategory_PATH(1),

  /// Request/Response Header
  GeneratorCategory_HEADER(2),

  /// Request Query Parameter
  GeneratorCategory_QUERY(3),

  /// Body
  GeneratorCategory_BODY(4),

  /// Response Status
  GeneratorCategory_STATUS(5),

  /// Message metadata
  GeneratorCategory_METADATA(6);

  final int value;
  const GeneratorCategory(this.value);

  static GeneratorCategory fromValue(int value) => switch (value) {
        0 => GeneratorCategory_METHOD,
        1 => GeneratorCategory_PATH,
        2 => GeneratorCategory_HEADER,
        3 => GeneratorCategory_QUERY,
        4 => GeneratorCategory_BODY,
        5 => GeneratorCategory_STATUS,
        6 => GeneratorCategory_METADATA,
        _ => throw ArgumentError('Unknown value for GeneratorCategory: $value'),
      };
}

/// Request or Response enum
enum InteractionPart {
  /// Request part
  InteractionPart_Request(0),

  /// Response part
  InteractionPart_Response(1);

  final int value;
  const InteractionPart(this.value);

  static InteractionPart fromValue(int value) => switch (value) {
        0 => InteractionPart_Request,
        1 => InteractionPart_Response,
        _ => throw ArgumentError('Unknown value for InteractionPart: $value'),
      };
}

/// An enum representing the log level to use.
///
/// This enum is passed to `log_attach_sink`, which defines where to direct
/// log output at the specified level or lower.
enum LevelFilter {
  LevelFilter_Off(0),
  LevelFilter_Error(1),
  LevelFilter_Warn(2),
  LevelFilter_Info(3),
  LevelFilter_Debug(4),
  LevelFilter_Trace(5);

  final int value;
  const LevelFilter(this.value);

  static LevelFilter fromValue(int value) => switch (value) {
        0 => LevelFilter_Off,
        1 => LevelFilter_Error,
        2 => LevelFilter_Warn,
        3 => LevelFilter_Info,
        4 => LevelFilter_Debug,
        5 => LevelFilter_Trace,
        _ => throw ArgumentError('Unknown value for LevelFilter: $value'),
      };
}

/// Enum defining the categories that matching rules can be applied to
enum MatchingRuleCategory {
  /// Request Method
  MatchingRuleCategory_METHOD(0),

  /// Request Path
  MatchingRuleCategory_PATH(1),

  /// Request/Response Header
  MatchingRuleCategory_HEADER(2),

  /// Request Query Parameter
  MatchingRuleCategory_QUERY(3),

  /// Body
  MatchingRuleCategory_BODY(4),

  /// Response Status
  MatchingRuleCategory_STATUS(5),

  /// Message contents (body)
  MatchingRuleCategory_CONTENTS(6),

  /// Message metadata
  MatchingRuleCategory_METADATA(7);

  final int value;
  const MatchingRuleCategory(this.value);

  static MatchingRuleCategory fromValue(int value) => switch (value) {
        0 => MatchingRuleCategory_METHOD,
        1 => MatchingRuleCategory_PATH,
        2 => MatchingRuleCategory_HEADER,
        3 => MatchingRuleCategory_QUERY,
        4 => MatchingRuleCategory_BODY,
        5 => MatchingRuleCategory_STATUS,
        6 => MatchingRuleCategory_CONTENTS,
        7 => MatchingRuleCategory_METADATA,
        _ =>
          throw ArgumentError('Unknown value for MatchingRuleCategory: $value'),
      };
}

/// Enum defining the pact specification versions supported by the library
enum PactSpecification {
  /// Unknown or unsupported specification version
  PactSpecification_Unknown(0),

  /// First version of the pact specification (<https://github.com/pact-foundation/pact-specification/tree/version-1>)
  PactSpecification_V1(1),

  /// Second version of the pact specification (<https://github.com/pact-foundation/pact-specification/tree/version-1.1>)
  PactSpecification_V1_1(2),

  /// Version two of the pact specification (<https://github.com/pact-foundation/pact-specification/tree/version-2>)
  PactSpecification_V2(3),

  /// Version three of the pact specification (<https://github.com/pact-foundation/pact-specification/tree/version-3>)
  PactSpecification_V3(4),

  /// Version four of the pact specification (<https://github.com/pact-foundation/pact-specification/tree/version-4>)
  PactSpecification_V4(5);

  final int value;
  const PactSpecification(this.value);

  static PactSpecification fromValue(int value) => switch (value) {
        0 => PactSpecification_Unknown,
        1 => PactSpecification_V1,
        2 => PactSpecification_V1_1,
        3 => PactSpecification_V2,
        4 => PactSpecification_V3,
        5 => PactSpecification_V4,
        _ => throw ArgumentError('Unknown value for PactSpecification: $value'),
      };
}

final class AsynchronousMessage extends ffi.Opaque {}

final class Consumer extends ffi.Opaque {}

final class Generator extends ffi.Opaque {}

final class GeneratorCategoryIterator extends ffi.Opaque {}

final class HttpRequest extends ffi.Opaque {}

final class HttpResponse extends ffi.Opaque {}

final class MatchingRule extends ffi.Opaque {}

final class MatchingRuleCategoryIterator extends ffi.Opaque {}

final class MatchingRuleDefinitionResult extends ffi.Opaque {}

final class MatchingRuleIterator extends ffi.Opaque {}

final class MatchingRuleResult extends ffi.Opaque {}

final class Message extends ffi.Opaque {}

final class MessageContents extends ffi.Opaque {}

final class MessageMetadataIterator extends ffi.Opaque {}

final class MessagePact extends ffi.Opaque {}

final class MessagePactMessageIterator extends ffi.Opaque {}

final class MessagePactMetadataIterator extends ffi.Opaque {}

final class Mismatch extends ffi.Opaque {}

final class Mismatches extends ffi.Opaque {}

final class MismatchesIterator extends ffi.Opaque {}

final class Pact extends ffi.Opaque {}

final class PactAsyncMessageIterator extends ffi.Opaque {}

final class PactInteraction extends ffi.Opaque {}

final class PactInteractionIterator extends ffi.Opaque {}

final class PactMessageIterator extends ffi.Opaque {}

final class PactSyncHttpIterator extends ffi.Opaque {}

final class PactSyncMessageIterator extends ffi.Opaque {}

final class Provider extends ffi.Opaque {}

final class ProviderState extends ffi.Opaque {}

final class ProviderStateIterator extends ffi.Opaque {}

final class ProviderStateParamIterator extends ffi.Opaque {}

final class SynchronousHttp extends ffi.Opaque {}

final class SynchronousMessage extends ffi.Opaque {}

final class VerifierHandle extends ffi.Opaque {}

/// A single key-value pair of a path and generator exported to the C-side.
final class GeneratorKeyValuePair extends ffi.Struct {
  /// The generator path
  external ffi.Pointer<ffi.Char> path;

  /// The generator
  external ffi.Pointer<Generator> generator;
}

/// A single key-value pair of a path and matching rule exported to the C-side.
final class MatchingRuleKeyValuePair extends ffi.Struct {
  /// The matching rule path
  external ffi.Pointer<ffi.Char> path;

  /// The matching rule
  external ffi.Pointer<MatchingRule> rule;
}

/// A single key-value pair exported to the C-side.
final class MessageMetadataPair extends ffi.Struct {
  /// The metadata key.
  external ffi.Pointer<ffi.Char> key;

  /// The metadata value.
  external ffi.Pointer<ffi.Char> value;
}

/// A triple, containing the outer key, inner key, and value, exported to the C-side.
final class MessagePactMetadataTriple extends ffi.Struct {
  /// The outer key of the `MessagePact` metadata.
  external ffi.Pointer<ffi.Char> outer_key;

  /// The inner key of the `MessagePact` metadata.
  external ffi.Pointer<ffi.Char> inner_key;

  /// The value of the `MessagePact` metadata.
  external ffi.Pointer<ffi.Char> value;
}

/// A single key-value pair exported to the C-side.
final class ProviderStateParamPair extends ffi.Struct {
  /// The key of the `ProviderState` parameter.
  external ffi.Pointer<ffi.Char> key;

  /// The value of the `ProviderState` parameter.
  external ffi.Pointer<ffi.Char> value;
}

/// Wraps a Pact model struct
typedef PactHandle = ffi.Uint16;
typedef DartPactHandle = int;

/// Result of wrapping a string value
enum StringResult_Tag {
  /// Was generated OK
  StringResult_Ok(0),

  /// There was an error generating the string
  StringResult_Failed(1);

  final int value;
  const StringResult_Tag(this.value);

  static StringResult_Tag fromValue(int value) => switch (value) {
        0 => StringResult_Ok,
        1 => StringResult_Failed,
        _ => throw ArgumentError('Unknown value for StringResult_Tag: $value'),
      };
}

final class UnnamedStruct extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ok;
}

final class UnnamedStruct$1 extends ffi.Struct {
  external ffi.Pointer<ffi.Char> failed;
}

final class UnnamedUnion extends ffi.Union {
  external UnnamedStruct unnamed;

  external UnnamedStruct$1 unnamed$1;
}

final class StringResult extends ffi.Struct {
  @ffi.UnsignedInt()
  external int tagAsInt;

  StringResult_Tag get tag => StringResult_Tag.fromValue(tagAsInt);

  external UnnamedUnion unnamed;
}

/// Wraps a Pact model struct
typedef InteractionHandle = ffi.Uint32;
typedef DartInteractionHandle = int;

/// Wraps a Pact model struct
typedef MessagePactHandle = ffi.Uint16;
typedef DartMessagePactHandle = int;

/// Wraps a Pact model struct
typedef MessageHandle = ffi.Uint32;
typedef DartMessageHandle = int;

const int __bool_true_false_are_defined = 1;

const int true$ = 1;

const int false$ = 0;

const int __WORDSIZE = 64;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __has_bounds_safety_attributes = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_KERNELKIT = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_13_7 = 130700;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __MAC_14_6 = 140600;

const int __MAC_14_7 = 140700;

const int __MAC_15_0 = 150000;

const int __MAC_15_1 = 150100;

const int __MAC_15_2 = 150200;

const int __MAC_15_3 = 150300;

const int __MAC_15_4 = 150400;

const int __MAC_15_5 = 150500;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __IPHONE_17_6 = 170600;

const int __IPHONE_17_7 = 170700;

const int __IPHONE_18_0 = 180000;

const int __IPHONE_18_1 = 180100;

const int __IPHONE_18_2 = 180200;

const int __IPHONE_18_3 = 180300;

const int __IPHONE_18_4 = 180400;

const int __IPHONE_18_5 = 180500;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __WATCHOS_10_6 = 100600;

const int __WATCHOS_10_7 = 100700;

const int __WATCHOS_11_0 = 110000;

const int __WATCHOS_11_1 = 110100;

const int __WATCHOS_11_2 = 110200;

const int __WATCHOS_11_3 = 110300;

const int __WATCHOS_11_4 = 110400;

const int __WATCHOS_11_5 = 110500;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __TVOS_17_6 = 170600;

const int __TVOS_18_0 = 180000;

const int __TVOS_18_1 = 180100;

const int __TVOS_18_2 = 180200;

const int __TVOS_18_3 = 180300;

const int __TVOS_18_4 = 180400;

const int __TVOS_18_5 = 180500;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __BRIDGEOS_8_6 = 80600;

const int __BRIDGEOS_9_0 = 90000;

const int __BRIDGEOS_9_1 = 90100;

const int __BRIDGEOS_9_2 = 90200;

const int __BRIDGEOS_9_3 = 90300;

const int __BRIDGEOS_9_4 = 90400;

const int __BRIDGEOS_9_5 = 90500;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __DRIVERKIT_23_6 = 230600;

const int __DRIVERKIT_24_0 = 240000;

const int __DRIVERKIT_24_1 = 240100;

const int __DRIVERKIT_24_2 = 240200;

const int __DRIVERKIT_24_3 = 240300;

const int __DRIVERKIT_24_4 = 240400;

const int __DRIVERKIT_24_5 = 240500;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int __VISIONOS_1_3 = 10300;

const int __VISIONOS_2_0 = 20000;

const int __VISIONOS_2_1 = 20100;

const int __VISIONOS_2_2 = 20200;

const int __VISIONOS_2_3 = 20300;

const int __VISIONOS_2_4 = 20400;

const int __VISIONOS_2_5 = 20500;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_13_7 = 130700;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int MAC_OS_VERSION_14_6 = 140600;

const int MAC_OS_VERSION_14_7 = 140700;

const int MAC_OS_VERSION_15_0 = 150000;

const int MAC_OS_VERSION_15_1 = 150100;

const int MAC_OS_VERSION_15_2 = 150200;

const int MAC_OS_VERSION_15_3 = 150300;

const int MAC_OS_VERSION_15_4 = 150400;

const int MAC_OS_VERSION_15_5 = 150500;

const int __AVAILABILITY_VERSIONS_VERSION_HASH = 93585900;

const String __AVAILABILITY_VERSIONS_VERSION_STRING = 'Local';

const String __AVAILABILITY_FILE = 'AvailabilityVersions.h';

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 150000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 150500;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int USER_ADDR_NULL = 0;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE = 2;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int BYTE_ORDER = 1234;

const int NULL = 0;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;
